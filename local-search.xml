<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>情人节快乐</title>
    <link href="/2023/02/14/%E6%83%85%E4%BA%BA%E8%8A%82%E5%BF%AB%E4%B9%90/"/>
    <url>/2023/02/14/%E6%83%85%E4%BA%BA%E8%8A%82%E5%BF%AB%E4%B9%90/</url>
    
    <content type="html"><![CDATA[<img src="/2023/02/14/%E6%83%85%E4%BA%BA%E8%8A%82%E5%BF%AB%E4%B9%90/1.jpg" class="">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/01/09/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/01/09/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="一、基础算法"><a href="#一、基础算法" class="headerlink" title="一、基础算法"></a>一、基础算法</h1><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p><strong>快速排序</strong></p><ul><li>1.确定分界点 $a[l]、a[h]、a[(l+h)&#x2F;2]$</li></ul><p>分界点取到左边界时不能以左指针作为边界分界，分界点取到右边界时不能以右指针作为分解点，否则会死循环。注意c++中整数除法下取整。若采用左右端点作为分界点时数据特殊时可能会超时，则采用 $（l + h） &gt;&gt; 1$作为分界点，以右指针作为分界边界。</p><ul><li>2.调整区间</li></ul><p>以左右两个指针从两侧向中间扫描，当两个指针均不符合条件时，交换两指针所指向的数</p><ul><li>3.递归处理左右两区间</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> h)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(l &gt;= h) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-type">int</span> x = q[l + h &gt;&gt; <span class="hljs-number">1</span>], <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>, <span class="hljs-type">int</span> j = h + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;j)&#123;<br>        <span class="hljs-keyword">do</span> i ++; <span class="hljs-keyword">while</span>(q[i] &lt; x);<br>        <span class="hljs-keyword">do</span> j --; <span class="hljs-keyword">while</span>(q[j] &gt; x);<br>        <span class="hljs-keyword">if</span>(i &lt; j ) <span class="hljs-built_in">swap</span>(q[i], q[j]);<br>    &#125;<br><br>    <span class="hljs-built_in">quick_sort</span>(q, l, j);<br>    <span class="hljs-built_in">quick_sort</span>(q, j+<span class="hljs-number">1</span>, h);<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>归并排序</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">AcWing788. 逆序对的数量</span><br><span class="hljs-comment">给定一个长度为 n 的整数数列，请你计算数列中的逆序对的数量。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">逆序对的定义如下：对于数列的第 i 个和第 j 个元素，如果满足 i&lt;j 且 a[i]&gt;a[j]，则其为一个逆序对；否则不是。</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> i64 = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-type">int</span> a[n + <span class="hljs-number">5</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) cin &gt;&gt; a[i];<br>     <br>    i64 res = <span class="hljs-number">0</span>;<br>    function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; merge_sort = [&amp;](<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)&#123;<br>        <span class="hljs-keyword">if</span>(l &gt;= r) <span class="hljs-keyword">return</span>;<br>        <br>        <span class="hljs-type">int</span> mid  = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <br>        <span class="hljs-built_in">merge_sort</span>(l, mid);<br>        <span class="hljs-built_in">merge_sort</span>(mid + <span class="hljs-number">1</span>, r);<br>        <br>        <span class="hljs-type">int</span> temp[r - l + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>, i = l, j = mid + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r)&#123;<br>            <span class="hljs-keyword">if</span>(a[i] &lt;= a[j]) temp[k ++] = a[i ++];<br>            <span class="hljs-keyword">else</span> &#123;<br>                res += (mid - i + <span class="hljs-number">1</span>);<br>                temp[k ++] = a[j ++];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(i &lt;= mid) &#123;<br>            temp[k ++] = a[i ++];<br>        &#125;<br>        <span class="hljs-keyword">while</span>(j &lt;= r) temp[k ++] = a[j ++];<br>        <br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = l; j &lt;= r;) a[j ++] = temp[i ++];<br>    &#125;;<br>    <br>    <span class="hljs-built_in">merge_sort</span>(<span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>); <br>    <br>    cout &lt;&lt; res &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h2><ul><li><p>整数二分</p><ul><li><p>思想：满足条件的划分在一个区间，不满足条件的在另一个区间</p></li><li><p>只要每次可以确定答案在某一半边就可以二分，不一定需要单调</p></li><li><p>当更新区间为 $l  &#x3D; mid$ 时 $mid$要取$ l + r  + 1 &gt;&gt; 1$,原因是c++中整数除法为下取整，当把$ l$ 更新为$mid$是若$ l &#x3D; r - 1$，此时 $mid &#x3D; l + r &gt;&gt; 1 $为$l$，陷入死循环。</p></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">AcWing 789. 数的范围</span><br><span class="hljs-comment">给定一个按照升序排列的长度为 n（均在 1∼10000 范围内） 的整数数组，以及 q 个查询。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">对于每个查询，返回一个元素 k 的起始位置和终止位置（位置从 0 开始计数）。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">如果数组中不存在该元素，则返回 -1 -1。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> a[N];<br><span class="hljs-type">int</span> n, q;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; q;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) cin &gt;&gt; a[i];<br>    <br>    <span class="hljs-keyword">while</span>(q --)&#123;<br>        <span class="hljs-type">int</span> k;<br>        cin &gt;&gt; k;<br>        <br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>            <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(a[mid] &gt;= k) r = mid;<br>            <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span>(a[l] != k)&#123;<br>            <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;-1 -1&quot;</span>);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<span class="hljs-keyword">else</span> cout &lt;&lt; l &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>        <br>        l = <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>            <span class="hljs-type">int</span> mid = l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(a[mid] &lt;= k) l = mid;<br>            <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>        cout &lt;&lt; l &lt;&lt; endl;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>浮点数二分</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span> </span>&#123;<span class="hljs-comment">/* ... */</span>&#125; <span class="hljs-comment">// 检查x是否满足某种性质</span><br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">bsearch_3</span><span class="hljs-params">(<span class="hljs-type">double</span> l, <span class="hljs-type">double</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-6</span>;   <span class="hljs-comment">// eps 表示精度，取决于题目对精度的要求</span><br>    <span class="hljs-keyword">while</span> (r - l &gt; eps)<br>    &#123;<br>        <span class="hljs-type">double</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) r = mid;<br>        <span class="hljs-keyword">else</span> l = mid;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>三分</p><ul><li>用途：确定单峰函数的极值</li><li>做法：每个选择区间的两个三等分点，把不可能是答案的那三分之一区间去掉</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">Codeforces Round #823 (Div. 2)-B</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-6</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100007</span>;<br><span class="hljs-type">double</span> a[N], t[N];<br><span class="hljs-type">int</span> n;<br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">double</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>        res = <span class="hljs-built_in">max</span>(res, <span class="hljs-built_in">abs</span>(a[i] - x) + t[i]);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sovle</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;   <br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>        cin &gt;&gt; a[i];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) <br>        cin &gt;&gt; t[i];<br><br>    <span class="hljs-type">double</span> l = <span class="hljs-number">0</span>, r = <span class="hljs-number">1e8</span>;<br>    <span class="hljs-keyword">while</span>(r - l &gt; eps)&#123;<br>        <span class="hljs-type">double</span> mid1 = l + (r - l) / <span class="hljs-number">3.0</span>;<br>        <span class="hljs-type">double</span> mid2 = r - (r - l) / <span class="hljs-number">3.0</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid1) &gt;= <span class="hljs-built_in">check</span>(mid2)) l = mid1;<br>        <span class="hljs-keyword">else</span> r = mid2;<br>    &#125;<br><br>    cout &lt;&lt; l &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>    cout &lt;&lt; <span class="hljs-built_in">setiosflags</span>(ios::fixed) &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">8</span>);<br><br>    <span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<br>    cin &gt;&gt; T;<br>    <span class="hljs-keyword">while</span>(T --)&#123;<br>        <span class="hljs-built_in">sovle</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h2><p><strong>高精度加法</strong></p><p>用数组存储每一位数字，低位在前，高位在后，模拟加法执行的过程算出结果</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// C = A + B, A &gt;= 0, B &gt;= 0</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">add</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, vector&lt;<span class="hljs-type">int</span>&gt; &amp;B)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (A.<span class="hljs-built_in">size</span>() &lt; B.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-built_in">add</span>(B, A);<br><br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>(); i ++ )<br>    &#123;<br>        t += A[i];<br>        <span class="hljs-keyword">if</span> (i &lt; B.<span class="hljs-built_in">size</span>()) t += B[i];<br>        C.<span class="hljs-built_in">push_back</span>(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (t) C.<span class="hljs-built_in">push_back</span>(t);<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>高精度减法</strong></p><p>与加法存储相同</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// C = A - B, 满足A &gt;= B, A &gt;= 0, B &gt;= 0</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sub</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, vector&lt;<span class="hljs-type">int</span>&gt; &amp;B)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, t = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>(); i ++ )<span class="hljs-comment">//t开始充当是否借位</span><br>    &#123;<br>        t = A[i] - t;<span class="hljs-comment">//t作为A[i] - B[i] - t 的结果</span><br>        <span class="hljs-keyword">if</span> (i &lt; B.<span class="hljs-built_in">size</span>()) t -= B[i];<br>        C.<span class="hljs-built_in">push_back</span>((t + <span class="hljs-number">10</span>) % <span class="hljs-number">10</span>);<span class="hljs-comment">//这里当t &gt; 0时，说明不用借位，运算结果为t</span><br>        <span class="hljs-keyword">if</span> (t &lt; <span class="hljs-number">0</span>) t = <span class="hljs-number">1</span>;   <span class="hljs-comment">//当 t &lt; 0时，要借位，此时结果加10</span><br>        <span class="hljs-keyword">else</span> t = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>高精度乘法</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// C = A * b, A &gt;= 0, b &gt;= 0</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">mul</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br><br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>() || t; i ++ )<span class="hljs-comment">//以t作为存在条件 是为了加上最后一位</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (i &lt; A.<span class="hljs-built_in">size</span>()) t += A[i] * b;<span class="hljs-comment">//因为以t作为存在条件了，所以这里需要判断i合法</span><br>        C.<span class="hljs-built_in">push_back</span>(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();<br><br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>高精度除法</strong></p><p>除法要从高位开始计算，因此为了保证与加减乘的统一，结果需要reverse</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// A / b = C ... r, A &gt;= 0, b &gt; 0</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">div</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> &amp;r)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    r = <span class="hljs-number">0</span>;<span class="hljs-comment">//不能在for内初始化会被覆盖掉，这里的r就不起作用了</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = A.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -- )<br>    &#123;<br>        r = r * <span class="hljs-number">10</span> + A[i];<br>        C.<span class="hljs-built_in">push_back</span>(r / b);<br>        r %= b;<br>    &#125;<br>    <span class="hljs-built_in">reverse</span>(C.<span class="hljs-built_in">begin</span>(), C.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">while</span> (C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="前缀和与差分"><a href="#前缀和与差分" class="headerlink" title="前缀和与差分"></a>前缀和与差分</h2><p><strong>前缀和</strong></p><p>$注意数组a从1开始 为了保证是s[r]  - s[l - 1]的边界适用$</p><p>$S[i] &#x3D; a[1] + a[2] + … a[i]$<br>$a[l] + … + a[r] &#x3D; S[r] - S[l - 1]$</p><p><strong>子矩阵和</strong></p><p>$S[i, j] &#x3D; 第i行j列格子左上部分所有元素的和$<br>$计算s[i, j]:s[i, j] &#x3D; s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + a[i][j]$<br>$以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：$<br>$S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]$</p><p><strong>差分</strong></p><p>$给区间[l, r]中的每个数加上c：B[l] +&#x3D; c, B[r + 1] -&#x3D; c$</p><p>$a是b的前缀和数组，b是的差分数组，不必去构造差分数组，运用*的思想，即可在读入a数组是构造完成b数组$</p><p><strong>差分矩阵</strong></p><p>$给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：$<br>$S[x1, y1] +&#x3D; c, S[x2 + 1, y1] -&#x3D; c, S[x1, y2 + 1] -&#x3D; c, S[x2 + 1, y2 + 1] +&#x3D; c$</p><p>思想同差分</p><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p>先写暴力算法，观察i ，j有什么单调关系，从而把枚举状态从O(n^2)优化到O(n)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>&#123;<br>    <span class="hljs-keyword">while</span> (j &lt; i &amp;&amp; <span class="hljs-built_in">check</span>(i, j)) j ++ ;<br><br>    <span class="hljs-comment">// 具体问题的逻辑</span><br>&#125;<br>常见问题分类：<br>    (<span class="hljs-number">1</span>) 对于一个序列，用两个指针维护一段区间<br>    (<span class="hljs-number">2</span>) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作<br></code></pre></td></tr></table></figure><h2 id="lowbit"><a href="#lowbit" class="headerlink" title="lowbit"></a>lowbit</h2><p>返回x的二进制表示以及最低位1以及后面的0</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> x &amp; -x;<br>    <span class="hljs-comment">// -x = ~x + 1</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//以区间和为例子</span><br>vector&lt;<span class="hljs-type">int</span>&gt; alls; <span class="hljs-comment">// 存储所有待离散化的值</span><br><span class="hljs-built_in">sort</span>(alls.<span class="hljs-built_in">begin</span>(), alls.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 将所有值排序</span><br>alls.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(alls.<span class="hljs-built_in">begin</span>(), alls.<span class="hljs-built_in">end</span>()), alls.<span class="hljs-built_in">end</span>());   <span class="hljs-comment">// 去掉重复元素</span><br><br><span class="hljs-comment">// 二分求出x对应的离散化的值</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> <span class="hljs-comment">// 找到第一个大于等于x的位置</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = alls.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (l &lt; r)<br>    &#123;<br>        <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (alls[mid] &gt;= x) r = mid;<br>        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> r + <span class="hljs-number">1</span>; <span class="hljs-comment">// 映射到1, 2, ...n</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="区间合并"><a href="#区间合并" class="headerlink" title="区间合并"></a>区间合并</h2><p>区间已经按左端点排序，考察当前区间及下一个区间，初始条件设为无穷，不要忘记对最后一个区间的考察</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 将所有存在交集的区间合并</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;PII&gt; &amp;segs)</span><br>&#123;<br>    <span class="hljs-built_in">vector</span>&lt;PII&gt; res;<br><br>    sort(segs.begin(), segs.end());<br><br>    <span class="hljs-type">int</span> st = <span class="hljs-number">-2e9</span>, ed = <span class="hljs-number">-2e9</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> seg : segs)<br>        <span class="hljs-keyword">if</span> (ed &lt; seg.first)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (st != <span class="hljs-number">-2e9</span>) res.push_back(&#123;st, ed&#125;);<br>            st = seg.first, ed = seg.second;<br>        &#125;<br>        <span class="hljs-keyword">else</span> ed = max(ed, seg.second);<br><br>    <span class="hljs-keyword">if</span> (st != <span class="hljs-number">-2e9</span>) res.push_back(&#123;st, ed&#125;);<br><br>    segs = res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="RMQ"><a href="#RMQ" class="headerlink" title="RMQ"></a>RMQ</h2><p>作用：快速找到一个区间内的最大或最小值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//预处理出f[i][j] 从i开始长度为2^j的区间内的最大值</span><br>f[i][j] = <span class="hljs-built_in">max</span>(f[i][j - <span class="hljs-number">1</span>], f[i + (<span class="hljs-number">1</span> &lt;&lt; j - <span class="hljs-number">1</span>)][j - <span class="hljs-number">1</span>])<br><span class="hljs-comment">//预处理循环时从长度循环，不能从每个点循环</span><br>用两个预处理出来的区间可以覆盖任意一个合理区间<br>    <span class="hljs-built_in">query</span>(l, r);<br><span class="hljs-type">int</span> len = r - l + <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> k = <span class="hljs-built_in">log</span>(len) / <span class="hljs-built_in">log</span>(<span class="hljs-number">2</span>);<span class="hljs-comment">//也可以预处理power[1 &lt;&lt; i] = i, k = power[len];</span><br>res = <span class="hljs-built_in">max</span>(f[l][k], f[r - (<span class="hljs-number">1</span> &lt;&lt; k) + <span class="hljs-number">1</span>][k]);<br></code></pre></td></tr></table></figure><h1 id="二、数据结构"><a href="#二、数据结构" class="headerlink" title="二、数据结构"></a>二、数据结构</h1><h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><p>用两个数组模拟链表，一个记录值，另一个记录next指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点，也就是节点编号</span><br><span class="hljs-type">int</span> head, e[N], ne[N], idx;<br><br><span class="hljs-comment">// 初始化</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    head = <span class="hljs-number">-1</span>;<br>    idx = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 在链表头插入一个数a</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = a, ne[idx] = head, head = idx ++ ;<br>&#125;<br><br><span class="hljs-comment">// 将头结点删除，需要保证头结点存在</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    head = ne[head];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h2><p>用两个数组记录左右指针 0位置为头，1位置为尾</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点</span><br><span class="hljs-type">int</span> e[N], l[N], r[N], idx;<br><br><span class="hljs-comment">// 初始化</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//0是左端点，1是右端点</span><br>    r[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>, l[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    idx = <span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-comment">// 在节点a的右边插入一个数x</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = x;<br>    l[idx] = a, r[idx] = r[a];<br>    l[r[a]] = idx, r[a] = idx ++ ;<br>&#125;<br><br><span class="hljs-comment">// 删除节点a</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>    l[r[a]] = l[a];<br>    r[l[a]] = r[a];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// tt表示栈顶</span><br><span class="hljs-type">int</span> stk[N], tt = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 向栈顶插入一个数</span><br>stk[ ++ tt] = x;<br><br><span class="hljs-comment">// 从栈顶弹出一个数</span><br>tt -- ;<br><br><span class="hljs-comment">// 栈顶的值</span><br>stk[tt];<br><br><span class="hljs-comment">// 判断栈是否为空</span><br><span class="hljs-keyword">if</span> (tt &gt; <span class="hljs-number">0</span>)<br>&#123;<br><br>&#125;<br><span class="hljs-comment">//普通队列</span><br><span class="hljs-comment">// hh 表示队头，tt表示队尾</span><br><span class="hljs-type">int</span> q[N], hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">-1</span>;<br><br><span class="hljs-comment">// 向队尾插入一个数</span><br>q[ ++ tt] = x;<br><br><span class="hljs-comment">// 从队头弹出一个数</span><br>hh ++ ;<br><br><span class="hljs-comment">// 队头的值</span><br>q[hh];<br><br><span class="hljs-comment">// 判断队列是否为空</span><br><span class="hljs-keyword">if</span> (hh &lt;= tt)<br>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="单调队列和单调栈"><a href="#单调队列和单调栈" class="headerlink" title="单调队列和单调栈"></a>单调队列和单调栈</h2><p>保持队列或栈中元素单调</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++">单调栈：常见模型：找出每个数左边离它最近的比它大/小的数<br><span class="hljs-type">int</span> tt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>&#123;<br>    <span class="hljs-keyword">while</span> (tt &amp;&amp; <span class="hljs-built_in">check</span>(stk[tt], i)) tt -- ;<br>    stk[ ++ tt] = i;<br>&#125;<br>单调队列 ：常见模型：找出滑动窗口中的最大值/最小值<br><span class="hljs-type">int</span> hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>&#123;<br>    <span class="hljs-keyword">while</span> (hh &lt;= tt &amp;&amp; <span class="hljs-built_in">check_out</span>(q[hh])) hh ++ ;  <span class="hljs-comment">// 判断队头是否滑出窗口</span><br>    <span class="hljs-keyword">while</span> (hh &lt;= tt &amp;&amp; <span class="hljs-built_in">check</span>(q[tt], i)) tt -- ;<br>    q[ ++ tt] = i;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="kmp"><a href="#kmp" class="headerlink" title="kmp"></a>kmp</h2><ul><li>性质 $n - ne[n]$ 就是把$1$到$n$覆盖的最小循环节长度， 如果$n$整除$n - ne[n]$, 那么其就是最小完全循环节长度</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// s是长文本，p是模式串，n是s的长度，m是p的长度</span><br>求模式串的Next数组：<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>, j = <span class="hljs-number">0</span>; i &lt;= m; i ++ )&#123;<br>    <span class="hljs-keyword">while</span> (j &amp;&amp; p[i] != p[j + <span class="hljs-number">1</span>]) j = ne[j];<br>    <span class="hljs-keyword">if</span> (p[i] == p[j + <span class="hljs-number">1</span>]) j ++ ;<br>    ne[i] = j;<br>&#125;<br><br><span class="hljs-comment">// 匹配</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; i &lt;= n; i ++ )<br>&#123;<br>    <span class="hljs-keyword">while</span> (j &amp;&amp; s[i] != p[j + <span class="hljs-number">1</span>]) j = ne[j];<br>    <span class="hljs-keyword">if</span> (s[i] == p[j + <span class="hljs-number">1</span>]) j ++ ;<br>    <span class="hljs-keyword">if</span> (j == m)<br>    &#123;<br>        j = ne[j];<br>        <span class="hljs-comment">// 匹配成功后的逻辑</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h2><p>用途：快速的存储和查找字符串</p><p>节点数为通常为每个串的最大长度乘以串的个数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++">son[N][M] N为节点个数，M为每个节点最多有多少个后代<br> idx当前操作的是总共的第几个节点，s[n][m]中记录的是第n个节点的m（通常是把可能的字符情况映射到数字）字符是否存在，若存在为第几个节点<br> 若是记录串出现次数，cnt[N]数组记录每个节点结尾的串的个数<br>    <br>    <span class="hljs-type">int</span> son[N][<span class="hljs-number">26</span>], cnt[N], idx;<br><span class="hljs-comment">// 0号点既是根节点，又是空节点</span><br><span class="hljs-comment">// son[][]存储树中每个节点的子节点</span><br><span class="hljs-comment">// cnt[]存储以每个节点结尾的单词数量</span><br><br><span class="hljs-comment">// 插入一个字符串</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">char</span> *str)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;<span class="hljs-comment">//（当前字符位置）</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; str[i]; i ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> u = str[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<span class="hljs-comment">//(找出当前字符)</span><br>        <span class="hljs-keyword">if</span> (!son[p][u]) son[p][u] = ++ idx;<span class="hljs-comment">//（判断树中是否存在，不存在则新建）</span><br>        p = son[p][u];<span class="hljs-comment">//（p移动到下一个字符位置）</span><br>    &#125;<br>    cnt[p] ++ ;<br>&#125;<br><br><span class="hljs-comment">// 查询字符串出现的次数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">char</span> *str)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; str[i]; i ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> u = str[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>        <span class="hljs-keyword">if</span> (!son[p][u]) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        p = son[p][u];<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt[p];<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="可持久化trie树"><a href="#可持久化trie树" class="headerlink" title="可持久化trie树"></a>可持久化trie树</h2><p>可持久化的含义的就是记录trie树更新的每个版本，</p><p>核心思想就是记录每个版本与上个版本不一样的即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">代码思路大致如下<br>p为上一版本的根节点， q为新版本的根节点<br>p = root[i - <span class="hljs-number">1</span>], q = ++ idx;<br><span class="hljs-keyword">if</span>(p) tr[q] = tr[p];<span class="hljs-comment">//所当前节点信息上一版本中有，复制过来即可</span><br> tr[p][si] = ++ idx;<span class="hljs-comment">//si为要插入的节点，新插入的节点总结总要从新建立，哪怕老版本中有，因为在新版本中要用到因此要从新建立，</span><br> p = tr[p][si];<span class="hljs-comment">//在新版本中用不到的老版本信息，使用老版本即可</span><br> q = tr[q][si];   <span class="hljs-comment">//这两行的意义为，先把老版本的信息完全复制过来，如果新版本中要用到老版本的，再从新建立</span><br><span class="hljs-comment">//老版本没有的也从新建立</span><br><br> <br></code></pre></td></tr></table></figure><hr><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><ul><li><p>将两个集合合并</p></li><li><p>询问两个元素是否在同一个集合中</p></li><li><p>基本原理：每个集合用一颗树表示，树根的编号就是整个集合的编号，每个节点存储它的父节点，$p[x]$表示$x$的父节点</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs c++">(<span class="hljs-number">1</span>)朴素并查集：<br><br>    <span class="hljs-type">int</span> p[N]; <span class="hljs-comment">//存储每个点的祖宗节点</span><br><br>    <span class="hljs-comment">// 返回x的祖宗节点 同时路径压缩</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (p[x] != x) p[x] = <span class="hljs-built_in">find</span>(p[x]);<br>        <span class="hljs-keyword">return</span> p[x];<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化，假定节点编号是1~n </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) p[i] = i;<br><br>    <span class="hljs-comment">// 合并a和b所在的两个集合：</span><br>    p[<span class="hljs-built_in">find</span>(a)] = <span class="hljs-built_in">find</span>(b);<br><br><br>(<span class="hljs-number">2</span>)维护size的并查集：<br><br>    <span class="hljs-type">int</span> p[N], size[N];<br>    <span class="hljs-comment">//p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量</span><br><br>    <span class="hljs-comment">// 返回x的祖宗节点 同时路径压缩</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (p[x] != x) p[x] = <span class="hljs-built_in">find</span>(p[x]);<br>        <span class="hljs-keyword">return</span> p[x];<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化，假定节点编号是1~n</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>    &#123;<br>        p[i] = i;<br>        size[i] = <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 合并a和b所在的两个集合：</span><br>    size[<span class="hljs-built_in">find</span>(b)] += size[<span class="hljs-built_in">find</span>(a)];<br>    p[<span class="hljs-built_in">find</span>(a)] = <span class="hljs-built_in">find</span>(b);<br><br><br>(<span class="hljs-number">3</span>)维护到祖宗节点距离的并查集：<br><br>    <span class="hljs-type">int</span> p[N], d[N];<br>    <span class="hljs-comment">//p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离</span><br><br>    <span class="hljs-comment">// 返回x的祖宗节点</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (p[x] != x)<br>        &#123;<br>            <span class="hljs-type">int</span> u = <span class="hljs-built_in">find</span>(p[x]);<br>            d[x] += d[p[x]];<br>            p[x] = u;<br>        &#125;<br>        <span class="hljs-keyword">return</span> p[x];<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化，假定节点编号是1~n</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>    &#123;<br>        p[i] = i;<br>        d[i] = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 合并a和b所在的两个集合：</span><br>    p[<span class="hljs-built_in">find</span>(a)] = <span class="hljs-built_in">find</span>(b);<br>    d[<span class="hljs-built_in">find</span>(a)] = distance; <span class="hljs-comment">// 根据具体问题，初始化find(a)的偏移量</span><br><br></code></pre></td></tr></table></figure><p>两种并查集：</p><ul><li>带边权的并查集</li></ul><p>所有可以相互推出关系的元素在一个集合内，通常关系是一个循环，以到根节点的距离表示与根节点的关系，再由与根节点的关系推出各个点之间的关系，通常要维护一个表示距离的数组d[], d[i]表示i到其父节点的距离，路径压缩过程中可同时更新d[]，</p><ul><li>带扩展域的并查集</li></ul><p>每个集合内存的是元素关系，一个关系成立，则集合内的其他关系必然成立，每次合并的复杂度是O(k)的，对于关系较多的问题可能运行较为缓慢，各种关系的表示要确定好表示方式，避免一种表示，表示两种关系</p><hr><h2 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h2><ul><li>作用：求前缀和，修改某一个数后的前缀和</li></ul><p>​单点加法， 和区间和</p><p>​因此要求的值必须能通过前缀和求出</p><ul><li>时间复杂度：求前缀和$O(logn)$, 修改某一个数$O(logn)$</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> x &amp; -x;<br>&#125;<br><span class="hljs-comment">//修改</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = x; i &lt;= n; i += <span class="hljs-built_in">lowbit</span>(i)) tr[i] += c;<br>&#125;<br><span class="hljs-comment">//求值</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = x; i; i -= <span class="hljs-built_in">lowbit</span>(i)) res += tr[i];<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h2><ul><li>把区间分成线段，叶子节点只有单个元素，通常每个节点为一个s结构体，结构体中维护各种所需要的信息，用数组模拟线段树，空间要开$4 * N$</li></ul><p>​空间需要开$4$倍因为 节点编号可能达到$4n$这个量级，比$4n$要小，中间很多点没用到，实际上只用到$2*n - 1$个点</p><p>​查询和修改复杂度均是$O(logn)$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">区间加询问区间和</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> LL = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>    <span class="hljs-type">int</span> l, r;<br>    LL sum;<br>    <span class="hljs-type">int</span> add;<br>&#125;tr[N &lt;&lt; <span class="hljs-number">2</span>];<br><span class="hljs-type">int</span> a[N];<br><span class="hljs-type">int</span> n, m;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    tr[u].sum = tr[u &lt;&lt; <span class="hljs-number">1</span>].sum + tr[u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>].sum;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(node &amp;rt, node &amp;l, node &amp;r)</span></span><br><span class="hljs-function"></span>&#123;<br>    l.sum += <span class="hljs-number">1ll</span> * (l.r - l.l + <span class="hljs-number">1</span>) * rt.add;<br>    l.add += rt.add;<br>    r.sum += <span class="hljs-number">1ll</span> * (r.r - r.l + <span class="hljs-number">1</span>) * rt.add;<br>    r.add += rt.add;<br>    rt.add = <span class="hljs-number">0</span>; <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">pushdown</span>(tr[u], tr[u &lt;&lt; <span class="hljs-number">1</span>], tr[u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(l == r)&#123;<br>        tr[u] = &#123;l, r, a[l], <span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    tr[u] = &#123;l, r&#125;;<br>    <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">build</span>(u &lt;&lt; <span class="hljs-number">1</span>, l, mid), <span class="hljs-built_in">build</span>(u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r);<br>    <span class="hljs-built_in">pushup</span>(u);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> d)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(l &lt;= tr[u].l &amp;&amp; tr[u].r &lt;= r)&#123;<br>        tr[u].add += d;<br>        tr[u].sum += <span class="hljs-number">1ll</span> * (tr[u].r - tr[u].l + <span class="hljs-number">1</span>) * d;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">pushdown</span>(u);<br>    <span class="hljs-type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(l &lt;= mid) <span class="hljs-built_in">modify</span>(u &lt;&lt; <span class="hljs-number">1</span>, l, r, d);<br>    <span class="hljs-keyword">if</span>(r &gt; mid) <span class="hljs-built_in">modify</span>(u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, l, r, d);<br>    <span class="hljs-built_in">pushup</span>(u);<br>&#125;<br><br><span class="hljs-function">LL <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(l &lt;= tr[u].l &amp;&amp; tr[u].r &lt;= r)<br>        <span class="hljs-keyword">return</span> tr[u].sum;<br><br>    <span class="hljs-built_in">pushdown</span>(u);<br>    <span class="hljs-type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="hljs-number">1</span>;<br>    LL res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(l &lt;= mid) res += <span class="hljs-built_in">query</span>(u &lt;&lt; <span class="hljs-number">1</span>, l, r);<br>    <span class="hljs-keyword">if</span>(r &gt; mid) res += <span class="hljs-built_in">query</span>(u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, l, r);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>        cin &gt;&gt; a[i];<br><br>    <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n);<br><br>    <span class="hljs-type">char</span> op[<span class="hljs-number">2</span>];<br>    <span class="hljs-type">int</span> l, r, d;<br>    <span class="hljs-keyword">while</span>(m --)&#123;<br>        cin &gt;&gt; op;<br>        <span class="hljs-keyword">if</span>(op[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;Q&#x27;</span>)&#123;<br>            cin &gt;&gt; l &gt;&gt; r;<br>            cout &lt;&lt; <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, l, r) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            cin &gt;&gt; l &gt;&gt; r &gt;&gt; d;<br>            <span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, l, r, d);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>势能线段树</p><p>这种线段树要维护的信息，难以对整个区间计算，比如对一个区间内的数开根号，取模等<br>但其有一种奇妙的性质，就是修改超过一定次数后，再修改区间内的数不变<br>势能线段树就是利用这种性质：对区间修改直接暴力递归到叶子节点修改，但在递归的过程中，若发现这个区间内的数修改后不变的话，就不用递归下去<br>时间复杂度 假设每个叶子节点最多修改k次后不变， 则修改的复杂度就是$O(nlogn*k)$ 最坏情况下每个点修改k次<br>查询复杂度就是正常的线段树复杂度$(nlogn)$</p></li><li><p>线段树合并</p><ul><li>动态开点，只把使用的点开出来</li><li>线段树合并的复杂度大致是$O(logn)$的，空间开$4 * n * logn$</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">有 n 个点，形成一个树状结构。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">有 m 次发放操作，每次选择两个点 x,y，对 x 到 y 的路径上（包括 x,y）的每个点发放一袋 z 类型的物品。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">求完成所有发放操作后，每个点存放最多的是哪种类型的物品。</span><br><span class="hljs-comment">n,z&lt;=1e5</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> LL = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100007</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> M = N &lt;&lt; <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> h[N], e[M], ne[M], idx;<br><span class="hljs-type">int</span> depth[N], fa[N][<span class="hljs-number">19</span>];<span class="hljs-comment">//16</span><br><span class="hljs-type">int</span> q[N];<br><span class="hljs-type">int</span> n, m;<br>vector&lt;array&lt;<span class="hljs-type">int</span>, 3&gt;&gt; <span class="hljs-built_in">a</span>(N);<br>vector&lt;<span class="hljs-type">int</span>&gt; hs;<br><span class="hljs-type">int</span> root[N];<span class="hljs-comment">//每个节点的对应线段树的根节点</span><br><span class="hljs-type">int</span> cnt;<span class="hljs-comment">//已使用的节点</span><br><span class="hljs-type">int</span> ans[N];<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>    <span class="hljs-type">int</span> lc, rc, mx, id;<br>&#125;tr[N * <span class="hljs-number">80</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = v, ne[idx] = h[u], h[u] = idx ++;<br>    e[idx] = u, ne[idx] = h[v], h[v] = idx ++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">lower_bound</span>(hs.<span class="hljs-built_in">begin</span>(), hs.<span class="hljs-built_in">end</span>(), x) - hs.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(depth, <span class="hljs-number">0x3f</span>, <span class="hljs-built_in">sizeof</span>(depth));<br>    depth[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>, depth[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">0</span>;<br>    q[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">while</span>(hh &lt;= tt)&#123;<br>        <span class="hljs-keyword">auto</span> t = q[hh ++];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[t]; ~i; i = ne[i])&#123;<br>            <span class="hljs-type">int</span> ver = e[i];<br>            <span class="hljs-keyword">if</span>(depth[ver] &gt; depth[t] + <span class="hljs-number">1</span>)&#123;<br>                depth[ver] = depth[t] + <span class="hljs-number">1</span>;<br>                fa[ver][<span class="hljs-number">0</span>] = t;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= <span class="hljs-number">16</span>; k ++)&#123;<br>                    fa[ver][k] = fa[fa[ver][k - <span class="hljs-number">1</span>]][k - <span class="hljs-number">1</span>];<br>                &#125;<br>                q[++ tt] = ver;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(depth[u] &lt; depth[v]) <span class="hljs-built_in">swap</span>(u, v);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">16</span>; k &gt;= <span class="hljs-number">0</span>; k --)<br>        <span class="hljs-keyword">if</span>(depth[fa[u][k]] &gt;= depth[v])<br>            u = fa[u][k];<br>    <span class="hljs-keyword">if</span>(u == v) <span class="hljs-keyword">return</span> u;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">16</span>; k &gt;= <span class="hljs-number">0</span>; k --)<br>        <span class="hljs-keyword">if</span>(fa[u][k] != fa[v][k])&#123;<br>            u = fa[u][k];<br>            v = fa[v][k];<br>        &#125;<br>    <span class="hljs-keyword">return</span> fa[u][<span class="hljs-number">0</span>];<br>&#125;<br><br><span class="hljs-comment">//线段树</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(tr[tr[u].lc].mx &gt;= tr[tr[u].rc].mx)&#123;<br>        tr[u].mx = tr[tr[u].lc].mx;<br>        tr[u].id = tr[tr[u].lc].id;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        tr[u].mx = tr[tr[u].rc].mx;<br>        tr[u].id = tr[tr[u].rc].id;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(u == <span class="hljs-number">0</span>) u = ++ cnt;<br>    <span class="hljs-keyword">if</span>(l == r)&#123;<br>        tr[u].mx += k, tr[u].id = l;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(x &lt;= mid) <span class="hljs-built_in">modify</span>(tr[u].lc, l, mid, x, k);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">modify</span>(tr[u].rc, mid + <span class="hljs-number">1</span>, r, x, k);<br>    <span class="hljs-built_in">pushup</span>(u);<br>&#125;<br><br><span class="hljs-comment">//合并线段树</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> r1, <span class="hljs-type">int</span> r2, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(!r1) <span class="hljs-keyword">return</span> r2;<br>    <span class="hljs-keyword">if</span>(!r2) <span class="hljs-keyword">return</span> r1;<br><br>    <span class="hljs-keyword">if</span>(l == r)&#123;<br>        tr[r1].mx += tr[r2].mx;<br>        <span class="hljs-keyword">return</span> r1;<br>    &#125;<br><br>    <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>    tr[r1].lc = <span class="hljs-built_in">merge</span>(tr[r1].lc, tr[r2].lc, l, mid);<br>    tr[r1].rc = <span class="hljs-built_in">merge</span>(tr[r1].rc, tr[r2].rc, mid + <span class="hljs-number">1</span>, r);<br>    <span class="hljs-built_in">pushup</span>(r1);<br>    <span class="hljs-keyword">return</span> r1;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[u]; ~i; i = ne[i])&#123;<br>        <span class="hljs-type">int</span> ver = e[i];<br>        <span class="hljs-keyword">if</span>(ver == fa[u][<span class="hljs-number">0</span>]) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-built_in">dfs</span>(ver);<br>        root[u] = <span class="hljs-built_in">merge</span>(root[u], root[ver], <span class="hljs-number">1</span>, hs.<span class="hljs-built_in">size</span>());<br>    &#125;<br>    <span class="hljs-comment">//要在这里求答案,因为合并父节点时可能会改变子节点的root信息</span><br>    <span class="hljs-keyword">if</span>(tr[root[u]].mx != <span class="hljs-number">0</span>) ans[u] = hs[tr[root[u]].id - <span class="hljs-number">1</span>];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sovle</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;   <br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(h));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i ++)&#123;<br>        <span class="hljs-type">int</span> u, v;<br>        cin &gt;&gt; u &gt;&gt; v;<br>        <span class="hljs-built_in">add</span>(u, v);<br>    &#125;<br><br>    <span class="hljs-built_in">bfs</span>();<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i ++)&#123;<br>        cin &gt;&gt; a[i][<span class="hljs-number">0</span>] &gt;&gt; a[i][<span class="hljs-number">1</span>] &gt;&gt; a[i][<span class="hljs-number">2</span>];<br>        hs.<span class="hljs-built_in">push_back</span>(a[i][<span class="hljs-number">2</span>]);<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(hs.<span class="hljs-built_in">begin</span>(), hs.<span class="hljs-built_in">end</span>());<br>    hs.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(hs.<span class="hljs-built_in">begin</span>(), hs.<span class="hljs-built_in">end</span>()), hs.<span class="hljs-built_in">end</span>());<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i ++)&#123;<br>        <span class="hljs-keyword">auto</span> [x, y, z] = a[i];<br>        <span class="hljs-type">int</span> p = <span class="hljs-built_in">lca</span>(x, y);<br>        z = <span class="hljs-built_in">find</span>(z);<br>        <span class="hljs-built_in">modify</span>(root[x], <span class="hljs-number">1</span>, hs.<span class="hljs-built_in">size</span>(), z, <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">modify</span>(root[y], <span class="hljs-number">1</span>, hs.<span class="hljs-built_in">size</span>(), z, <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">modify</span>(root[p], <span class="hljs-number">1</span>, hs.<span class="hljs-built_in">size</span>(), z, <span class="hljs-number">-1</span>);<br>        <span class="hljs-built_in">modify</span>(root[fa[p][<span class="hljs-number">0</span>]], <span class="hljs-number">1</span>, hs.<span class="hljs-built_in">size</span>(), z, <span class="hljs-number">-1</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>        cout &lt;&lt; ans[i] &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>    cout &lt;&lt; <span class="hljs-built_in">setiosflags</span>(ios::fixed) &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">2</span>);<br>    <span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//cin &gt;&gt; T;</span><br>    <span class="hljs-keyword">while</span>(T --)&#123;<br>        <span class="hljs-built_in">sovle</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="可持久化线段树（主席树）"><a href="#可持久化线段树（主席树）" class="headerlink" title="可持久化线段树（主席树）"></a>可持久化线段树（主席树）</h2><p>区间修改操作较为困难，</p><p>记录了线段树每次修改的情况，一共有m + 1个版本，m为操作次数，空树也为一个版本</p><p>空间要开N * 4 + M * logN, 空间要特别注意，很容易开小</p><p>每次修改就是把信息改变的节点从新生成即可，每次修改的节点大概是logN级别</p><p>主席树的存储方式不再沿用堆的存储方式，因为每个版本要开新的节点，用数组存储，每个元素是个节点，每个节点存在左右儿子，</p><p>节点中不在存储，左右边界，因此，插入、询问时要传入左右边界 ，经典的例子有acwing 257题 第k小数</p><p>可持久化线段树与可持久化trie不同，每一个版本节点数量相同，只是信息改变，因此，先复制上一版本的所有信息，信息改变的节点从新创建</p><h2 id="平衡树（treap）"><a href="#平衡树（treap）" class="headerlink" title="平衡树（treap）"></a>平衡树（treap）</h2><p>平衡树可快速插入和查找$O(logn)$</p><p>维护搜索树的性质的同时维护堆的性质，这两个性质的就可以使得树的形状确定，同时堆的性质使得树的高度不至于退化成一条链，平均树高$logn$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> root, idx;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;<br>    <span class="hljs-type">int</span> lc, rc;<br>    <span class="hljs-type">int</span> key, val;<br>    <span class="hljs-type">int</span> cnt, size;<br>&#125;tr[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function"></span>&#123;<br>    tr[p].size = tr[tr[p].lc].size + tr[tr[p].rc].size + tr[p].cnt;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_node</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span></span><br><span class="hljs-function"></span>&#123;<br>    tr[++ idx].key = key;<br>    tr[idx].val = <span class="hljs-built_in">rand</span>();<br>    tr[idx].cnt = tr[idx].size = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> idx;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">zag</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;p)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">get_node</span>(-INF);<br>    <span class="hljs-built_in">get_node</span>(INF);<br>    root = <span class="hljs-number">1</span>, tr[<span class="hljs-number">1</span>].rc = <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">pushup</span>(root);<br>    <br>    <span class="hljs-keyword">if</span>(tr[<span class="hljs-number">1</span>].val &lt; tr[<span class="hljs-number">2</span>].val) <span class="hljs-built_in">zag</span>(root);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">zig</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;p)</span><span class="hljs-comment">//右旋</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> q = tr[p].lc;<br>    tr[p].lc = tr[q].rc;<br>    tr[q].rc = p;<br>    p = q;<br>    <span class="hljs-built_in">pushup</span>(tr[p].rc); <span class="hljs-built_in">pushup</span>(p);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">zag</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;p)</span><span class="hljs-comment">//左旋</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> q = tr[p].rc;<br>    tr[p].rc = tr[q].lc;<br>    tr[q].lc = p;<br>    p = q;<br>    <span class="hljs-built_in">pushup</span>(tr[p].lc); <span class="hljs-built_in">pushup</span>(p);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;p, <span class="hljs-type">int</span> key)</span><span class="hljs-comment">//插入</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(!p) p = <span class="hljs-built_in">get_node</span>(key);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tr[p].key == key) tr[p].cnt ++;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key &lt; tr[p].key)&#123;<br>        <span class="hljs-built_in">insert</span>(tr[p].lc, key);<br>        <span class="hljs-keyword">if</span>(tr[tr[p].lc].val &gt; tr[p].val) <span class="hljs-built_in">zig</span>(p);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">insert</span>(tr[p].rc, key);<br>        <span class="hljs-keyword">if</span>(tr[tr[p].rc].val &gt; tr[p].val) <span class="hljs-built_in">zag</span>(p);<br>    &#125;<br>    <span class="hljs-built_in">pushup</span>(p);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;p, <span class="hljs-type">int</span> key)</span><span class="hljs-comment">//删除</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(!p) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span>(tr[p].key == key)&#123;<br>        <span class="hljs-keyword">if</span>(tr[p].cnt &gt; <span class="hljs-number">1</span>) tr[p].cnt --;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(tr[p].lc || tr[p].rc)&#123;<br>                <span class="hljs-keyword">if</span>(!tr[p].rc || tr[tr[p].lc].val &gt; tr[tr[p].rc].val)&#123;<br>                    <span class="hljs-built_in">zig</span>(p);<br>                    <span class="hljs-built_in">remove</span>(tr[p].rc, key);<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-built_in">zag</span>(p);<br>                    <span class="hljs-built_in">remove</span>(tr[p].lc, key);<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span> p = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key &lt; tr[p].key) <span class="hljs-built_in">remove</span>(tr[p].lc, key);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">remove</span>(tr[p].rc, key);<br>    <br>    <span class="hljs-built_in">pushup</span>(p);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_rank_by_key</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> key)</span><span class="hljs-comment">//通过数值找排名</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(!p) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(tr[p].key == key) <span class="hljs-keyword">return</span> tr[tr[p].lc].size + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(key &lt; tr[p].key) <span class="hljs-keyword">return</span> <span class="hljs-built_in">get_rank_by_key</span>(tr[p].lc, key);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> tr[tr[p].lc].size + tr[p].cnt + <span class="hljs-built_in">get_rank_by_key</span>(tr[p].rc, key);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_key_by_rank</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> rank)</span><span class="hljs-comment">//通过排名找数值</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(!p) <span class="hljs-keyword">return</span> INF;<br>    <span class="hljs-keyword">if</span>(rank &lt;= tr[tr[p].lc].size) <span class="hljs-keyword">return</span> <span class="hljs-built_in">get_key_by_rank</span>(tr[p].lc, rank);<br>    <span class="hljs-keyword">if</span>(rank &lt;= tr[tr[p].lc].size + tr[p].cnt) <span class="hljs-keyword">return</span> tr[p].key;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">get_key_by_rank</span>(tr[p].rc, rank - tr[tr[p].lc].size - tr[p].cnt);<br>&#125;<br><br><span class="hljs-comment">//这两段找前驱后继，很精简巧妙</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_prec</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> key)</span><span class="hljs-comment">//找前驱（严格小于）</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(!p) <span class="hljs-keyword">return</span> -INF;<br>    <span class="hljs-keyword">if</span>(key &lt;= tr[p].key) <span class="hljs-keyword">return</span> <span class="hljs-built_in">get_prec</span>(tr[p].lc, key);<span class="hljs-comment">//若找小于等于 去掉等号</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(tr[p].key, <span class="hljs-built_in">get_prec</span>(tr[p].rc, key));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_succ</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> key)</span><span class="hljs-comment">//找后继（严格大于）</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(!p) <span class="hljs-keyword">return</span> INF;<br>    <span class="hljs-keyword">if</span>(key &gt;= tr[p].key) <span class="hljs-keyword">return</span> <span class="hljs-built_in">get_succ</span>(tr[p].rc, key);<span class="hljs-comment">//若找大于等于 去掉等号</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(tr[p].key, <span class="hljs-built_in">get_succ</span>(tr[p].lc, key));<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Splay"><a href="#Splay" class="headerlink" title="Splay"></a>Splay</h2><ul><li><p>$splay$ 能够$O(logn)$的原因是，在旋转时，对一条链的路径进行了折叠</p></li><li><p>核心只有$splay$和$rotate$两个函数，其他函数，依据需要添加即可。</p></li></ul><p>​$splay$函数的作用是把$x$节点调整到$k$节点的面，$k$为0，即让$x$作为根节点。</p><p>​切记 如果将x调整到k的下面，一定先将k调整到根节点，不然会死循环。</p><p>​处处$splay$!!!</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*AcWing 253.普通平衡树</span><br><span class="hljs-comment">您需要写一种数据结构（可参考题目标题），来维护一些数，其中需要提供以下操作：</span><br><span class="hljs-comment">1.插入数值 x。</span><br><span class="hljs-comment">2.删除数值 x(若有多个相同的数，应只删除一个)。</span><br><span class="hljs-comment">3.查询数值 x 的排名(若有多个相同的数，应输出最小的排名)。</span><br><span class="hljs-comment">4.查询排名为 x 的数值。</span><br><span class="hljs-comment">5.求数值 x 的前驱(前驱定义为小于 x 的最大的数)。</span><br><span class="hljs-comment">6.求数值 x 的后继(后继定义为大于 x 的最小的数)。</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1000010</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br><span class="hljs-type">int</span> s[<span class="hljs-number">2</span>], v, p;<br><span class="hljs-type">int</span> sz, cnt;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> _v, <span class="hljs-type">int</span> _p)</span></span>&#123;<br>v = _v, p = _p;<br>sz = cnt = <span class="hljs-number">1</span>;<br>&#125;<br>&#125;tr[N];<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> root, idx;<br><span class="hljs-type">int</span> tag;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>tr[u].sz = tr[tr[u].s[<span class="hljs-number">0</span>]].sz + tr[tr[u].s[<span class="hljs-number">1</span>]].sz + tr[u].cnt;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> y = tr[x].p, z = tr[y].p;<br><span class="hljs-type">int</span> k = x == tr[y].s[<span class="hljs-number">1</span>];<br>tr[x].p = z, tr[z].s[y == tr[z].s[<span class="hljs-number">1</span>]] = x;<br>tr[y].s[k] = tr[x].s[k ^ <span class="hljs-number">1</span>], tr[tr[x].s[k ^ <span class="hljs-number">1</span>]].p = y;<br>tr[y].p = x, tr[x].s[k ^ <span class="hljs-number">1</span>] = y;<br><span class="hljs-built_in">pushup</span>(y), <span class="hljs-built_in">pushup</span>(x);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">splay</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">while</span>(tr[x].p != k)&#123;<br><span class="hljs-type">int</span> y = tr[x].p, z = tr[y].p;<br><span class="hljs-keyword">if</span>(z != k)<br><span class="hljs-keyword">if</span>((x == tr[y].s[<span class="hljs-number">1</span>]) ^ (y == tr[z].s[<span class="hljs-number">1</span>])) <span class="hljs-built_in">rotate</span>(x);<br><span class="hljs-keyword">else</span> <span class="hljs-built_in">rotate</span>(y);<br><span class="hljs-built_in">rotate</span>(x);<br>&#125;<br><span class="hljs-keyword">if</span>(!k) root = x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> u = root, p = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(u)&#123;<br><span class="hljs-keyword">if</span>(v == tr[u].v)&#123;<br>tr[u].cnt ++;<br>tr[u].sz ++;<br><span class="hljs-built_in">splay</span>(u, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">break</span>;<br>&#125;<br>p = u, u = tr[u].s[v &gt; tr[u].v];<br>&#125;<br><br><span class="hljs-keyword">if</span>(!u)&#123;<br>u = ++ idx;<br><span class="hljs-keyword">if</span>(p) tr[p].s[v &gt; tr[p].v] = u;<br>tr[u].<span class="hljs-built_in">init</span>(v, p);<br><span class="hljs-built_in">splay</span>(u, <span class="hljs-number">0</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_pre</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span><span class="hljs-comment">//找前驱</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> u = root, res = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(u)&#123;<br><span class="hljs-keyword">if</span>(tr[u].v &gt;= v) u = tr[u].s[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">else</span> res = u, u = tr[u].s[<span class="hljs-number">1</span>];<br>&#125;<br><br><span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_suc</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span><span class="hljs-comment">//找后继</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> u = root, res = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(u)&#123;<br><span class="hljs-keyword">if</span>(tr[u].v &lt;= v) u = tr[u].s[<span class="hljs-number">1</span>];<br><span class="hljs-keyword">else</span> res = u, u = tr[u].s[<span class="hljs-number">0</span>];<br>&#125;<br><br><span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_rank</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span><span class="hljs-comment">//通过数值找排名</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(!u) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">if</span>(tr[u].v == v)&#123;<br>tag = u;<br><span class="hljs-keyword">return</span> tr[tr[u].s[<span class="hljs-number">0</span>]].sz + <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(v &lt; tr[u].v) <span class="hljs-keyword">return</span> <span class="hljs-built_in">get_rank</span>(tr[u].s[<span class="hljs-number">0</span>], v);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> tr[tr[u].s[<span class="hljs-number">0</span>]].sz + tr[u].cnt + <span class="hljs-built_in">get_rank</span>(tr[u].s[<span class="hljs-number">1</span>], v);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_k</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span><span class="hljs-comment">//通过排名找数值</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> u = root;<br><span class="hljs-keyword">while</span>(u)&#123;<br><span class="hljs-keyword">if</span>(tr[tr[u].s[<span class="hljs-number">0</span>]].sz &gt;= k) u = tr[u].s[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tr[tr[u].s[<span class="hljs-number">0</span>]].sz &lt; k &amp;&amp; tr[tr[u].s[<span class="hljs-number">0</span>]].sz + tr[u].cnt &gt;= k) <span class="hljs-keyword">return</span> u;<br><span class="hljs-keyword">else</span> k -= tr[tr[u].s[<span class="hljs-number">0</span>]].sz + tr[u].cnt, u = tr[u].s[<span class="hljs-number">1</span>];<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><br>cin &gt;&gt; n;<br><span class="hljs-built_in">insert</span>(-INF);<br><span class="hljs-built_in">insert</span>(INF);<br><span class="hljs-keyword">while</span>(n --)&#123;<br><span class="hljs-type">int</span> op, x;<br>cin &gt;&gt; op &gt;&gt; x;<br><span class="hljs-keyword">if</span>(op == <span class="hljs-number">1</span>)&#123;<br><span class="hljs-built_in">insert</span>(x);<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op == <span class="hljs-number">2</span>)&#123;<br><span class="hljs-type">int</span> l = <span class="hljs-built_in">get_pre</span>(x), r = <span class="hljs-built_in">get_suc</span>(x);<br><span class="hljs-built_in">splay</span>(l, <span class="hljs-number">0</span>), <span class="hljs-built_in">splay</span>(r, l);<br><br>tr[tr[r].s[<span class="hljs-number">0</span>]].sz --;<br><span class="hljs-keyword">if</span>(-- tr[tr[r].s[<span class="hljs-number">0</span>]].cnt == <span class="hljs-number">0</span>)<br> tr[r].s[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><br><span class="hljs-built_in">pushup</span>(r), <span class="hljs-built_in">pushup</span>(l);<br><span class="hljs-keyword">if</span>(tr[r].s[<span class="hljs-number">0</span>]) <span class="hljs-built_in">splay</span>(tr[r].s[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>);<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op == <span class="hljs-number">3</span>)&#123;<br>cout &lt;&lt; <span class="hljs-built_in">get_rank</span>(root, x) - <span class="hljs-number">1</span> &lt;&lt; endl;<br><span class="hljs-built_in">splay</span>(tag, <span class="hljs-number">0</span>);<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op == <span class="hljs-number">4</span>)&#123;<br><span class="hljs-type">int</span> u = <span class="hljs-built_in">get_k</span>(x + <span class="hljs-number">1</span>);<br>cout &lt;&lt; tr[u].v &lt;&lt; endl;<br><span class="hljs-built_in">splay</span>(u, <span class="hljs-number">0</span>);<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op == <span class="hljs-number">5</span>)&#123;<br><span class="hljs-type">int</span> u = <span class="hljs-built_in">get_pre</span>(x);<br>cout &lt;&lt; tr[u].v &lt;&lt; endl;<br><span class="hljs-built_in">splay</span>(u, <span class="hljs-number">0</span>);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-type">int</span> u = <span class="hljs-built_in">get_suc</span>(x);<br>cout &lt;&lt; tr[u].v &lt;&lt; endl;<br><span class="hljs-built_in">splay</span>(u, <span class="hljs-number">0</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="树套树"><a href="#树套树" class="headerlink" title="树套树"></a>树套树</h2><ul><li><p>线段树套multiset</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">AcWing 2488.树套树简单版</span><br><span class="hljs-comment">请你写出一种数据结构，来维护一个长度为 n 的序列，其中需要提供以下操作：</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">1 pos x，将 pos 位置的数修改为 x。</span><br><span class="hljs-comment">2 l r x，查询整数 x 在区间 [l,r] 内的前驱(前驱定义为小于 x，且最大的数)。</span><br><span class="hljs-comment">数列中的位置从左到右依次标号为 1∼n。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">区间 [l,r] 表示从位置 l 到位置 r 之间（包括两端点）的所有数字。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">区间内排名为 k 的值指区间内从小到大排在第 k 位的数值。（位次从 1 开始）</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">50010</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>    <span class="hljs-type">int</span> l, r;<br>    multiset&lt;<span class="hljs-type">int</span>&gt; ms;<br>&#125;tr[N &lt;&lt; <span class="hljs-number">2</span>];<br><span class="hljs-type">int</span> a[N];<br><span class="hljs-type">int</span> n, m;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    tr[u] = &#123;l, r&#125;;<br>    tr[u].ms.<span class="hljs-built_in">insert</span>(-INF), tr[u].ms.<span class="hljs-built_in">insert</span>(INF);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = l; i &lt;= r; i ++)<br>        tr[u].ms.<span class="hljs-built_in">insert</span>(a[i]);<br>    <span class="hljs-keyword">if</span>(l == r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">build</span>(u &lt;&lt; <span class="hljs-number">1</span>, l, mid), <span class="hljs-built_in">build</span>(u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> pos, <span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    tr[u].ms.<span class="hljs-built_in">erase</span>(tr[u].ms.<span class="hljs-built_in">find</span>(a[pos]));<br>    tr[u].ms.<span class="hljs-built_in">insert</span>(x);<br>    <br>    <span class="hljs-keyword">if</span>(tr[u].l == tr[u].r) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(pos &lt;= mid) <span class="hljs-built_in">modify</span>(u &lt;&lt; <span class="hljs-number">1</span>, pos, x);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">modify</span>(u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, pos, x); <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(l &lt;= tr[u].l &amp;&amp; tr[u].r &lt;= r)&#123;<br>        <span class="hljs-keyword">auto</span> it = tr[u].ms.<span class="hljs-built_in">lower_bound</span>(x);<br>        it --;<br>        <span class="hljs-keyword">return</span> *it;<br>    &#125;<br><br>    <span class="hljs-type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> res = -INF;<br>    <span class="hljs-keyword">if</span>(l &lt;= mid) res = <span class="hljs-built_in">max</span>(res, <span class="hljs-built_in">query</span>(u &lt;&lt; <span class="hljs-number">1</span>, l, r, x));<br>    <span class="hljs-keyword">if</span>(r &gt; mid) res = <span class="hljs-built_in">max</span>(res, <span class="hljs-built_in">query</span>(u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, l, r, x));<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;   <br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>        cin &gt;&gt; a[i];<br><br>    <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n);<br><br>    <span class="hljs-keyword">while</span>(m --)&#123;<br>        <span class="hljs-type">int</span> op, l, r, x;<br>        cin &gt;&gt; op;<br>        <span class="hljs-keyword">if</span>(op == <span class="hljs-number">1</span>)&#123;<br>            cin &gt;&gt; l &gt;&gt; x;<br>            <span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, l, x);<br>            a[l] = x;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            cin &gt;&gt; l &gt;&gt; r &gt;&gt; x;<br>            cout &lt;&lt; <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, l, r, x) &lt;&lt; endl;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>线段树套splay</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">AcWing 2476.树套树</span><br><span class="hljs-comment">请你写出一种数据结构，来维护一个长度为 n 的数列，其中需要提供以下操作：</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">1 l r x，查询整数 x 在区间 [l,r] 内的排名。</span><br><span class="hljs-comment">2 l r k，查询区间 [l,r] 内排名为 k 的值。</span><br><span class="hljs-comment">3 pos x，将 pos 位置的数修改为 x。</span><br><span class="hljs-comment">4 l r x，查询整数 x 在区间 [l,r] 内的前驱(前驱定义为小于 x，且最大的数)。</span><br><span class="hljs-comment">5 l r x，查询整数 x 在区间 [l,r] 内的后继(后继定义为大于 x，且最小的数)。</span><br><span class="hljs-comment">数列中的位置从左到右依次标号为 1∼n。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">区间 [l,r] 表示从位置 l 到位置 r 之间（包括两端点）的所有数字。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">区间内排名为 k 的值指区间内从小到大排在第 k 位的数值。（位次从 1 开始）</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">15000010</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>    <span class="hljs-type">int</span> s[<span class="hljs-number">2</span>], v, p;<br>    <span class="hljs-type">int</span> sz;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> _v, <span class="hljs-type">int</span> _p)</span></span>&#123;<br>        v = _v, p = _p;<br>        sz = <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;tr[N];<br><span class="hljs-type">int</span> L[N], R[N], T[N], idx;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> a[N];<br><br><span class="hljs-comment">//splay</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    tr[u].sz = tr[tr[u].s[<span class="hljs-number">0</span>]].sz + tr[tr[u].s[<span class="hljs-number">1</span>]].sz + <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> y = tr[x].p, z = tr[y].p;<br>    <span class="hljs-type">int</span> k = x == tr[y].s[<span class="hljs-number">1</span>];<br>    tr[x].p = z, tr[z].s[y == tr[z].s[<span class="hljs-number">1</span>]] = x;<br>    tr[y].s[k] = tr[x].s[k ^ <span class="hljs-number">1</span>], tr[tr[x].s[k ^ <span class="hljs-number">1</span>]].p = y;<br>    tr[y].p = x, tr[x].s[k ^ <span class="hljs-number">1</span>] = y;<br>    <span class="hljs-built_in">pushup</span>(y), <span class="hljs-built_in">pushup</span>(x);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">splay</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;root, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span>(tr[x].p != k)&#123;<br>        <span class="hljs-type">int</span> y = tr[x].p, z = tr[y].p;<br>        <span class="hljs-keyword">if</span>(z != k)<br>            <span class="hljs-keyword">if</span>((x == tr[y].s[<span class="hljs-number">1</span>]) ^ (y == tr[z].s[<span class="hljs-number">1</span>])) <span class="hljs-built_in">rotate</span>(x);<br>            <span class="hljs-keyword">else</span> <span class="hljs-built_in">rotate</span>(y);<br>        <span class="hljs-built_in">rotate</span>(x);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(!k) root = x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;root, <span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> u = root, p = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(u) p = u, u = tr[u].s[v &gt; tr[u].v];<br>    u = ++ idx;<br>    <span class="hljs-keyword">if</span>(p) tr[p].s[v &gt; tr[p].v] = u;<br>    tr[u].<span class="hljs-built_in">init</span>(v, p);<br>    <span class="hljs-built_in">splay</span>(root, u, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_pre</span><span class="hljs-params">(<span class="hljs-type">int</span> root, <span class="hljs-type">int</span> v)</span><span class="hljs-comment">//找数值前驱</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> u = root, res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(u)&#123;<br>        <span class="hljs-keyword">if</span>(tr[u].v &gt;= v) u = tr[u].s[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">else</span> res = u, u = tr[u].s[<span class="hljs-number">1</span>]; <br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_suc</span><span class="hljs-params">(<span class="hljs-type">int</span> root, <span class="hljs-type">int</span> v)</span><span class="hljs-comment">//找数值后继</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> u = root, res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(u)&#123;<br>        <span class="hljs-keyword">if</span>(tr[u].v &lt;= v) u = tr[u].s[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">else</span> res = u, u = tr[u].s[<span class="hljs-number">0</span>];<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_k</span><span class="hljs-params">(<span class="hljs-type">int</span> root, <span class="hljs-type">int</span> v)</span><span class="hljs-comment">//小于v的数值个数</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> u = root, res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(u)&#123;<br>        <span class="hljs-keyword">if</span>(tr[u].v &lt; v) res += tr[tr[u].s[<span class="hljs-number">0</span>]].sz + <span class="hljs-number">1</span>, u = tr[u].s[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">else</span> u = tr[u].s[<span class="hljs-number">0</span>];<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">//线段树</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    L[u] = l, R[u] = r;<br>    <span class="hljs-built_in">insert</span>(T[u], -INF), <span class="hljs-built_in">insert</span>(T[u], INF);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = l; i &lt;= r; i ++)<br>        <span class="hljs-built_in">insert</span>(T[u], a[i]);<br>    <span class="hljs-keyword">if</span>(l == r) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">build</span>(u &lt;&lt; <span class="hljs-number">1</span>, l, mid), <span class="hljs-built_in">build</span>(u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;root, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span><span class="hljs-comment">//每个树中区间更新</span></span><br><span class="hljs-function"></span>&#123;   <br>    <span class="hljs-type">int</span> u = root;<br>    <span class="hljs-keyword">while</span>(u)&#123;<br>        <span class="hljs-keyword">if</span>(tr[u].v == x) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tr[u].v &lt; x) u = tr[u].s[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">else</span> u = tr[u].s[<span class="hljs-number">0</span>];<br>    &#125;<br>    <span class="hljs-built_in">splay</span>(root, u, <span class="hljs-number">0</span>);<br>    <span class="hljs-type">int</span> l = tr[u].s[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">while</span>(tr[l].s[<span class="hljs-number">1</span>]) l = tr[l].s[<span class="hljs-number">1</span>];<br>    <span class="hljs-type">int</span> r = tr[u].s[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">while</span>(tr[r].s[<span class="hljs-number">0</span>]) r = tr[r].s[<span class="hljs-number">0</span>];<br>    <span class="hljs-built_in">splay</span>(root, l, <span class="hljs-number">0</span>), <span class="hljs-built_in">splay</span>(root, r, l);<br>    tr[r].s[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">pushup</span>(r), <span class="hljs-built_in">pushup</span>(l);<br>    <span class="hljs-built_in">insert</span>(root, y);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> pos, <span class="hljs-type">int</span> x)</span><span class="hljs-comment">//线段树修改</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">update</span>(T[u], a[pos], x);<br>    <span class="hljs-keyword">if</span>(L[u] == R[u]) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> mid = L[u] + R[u] &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(pos &lt;= mid) <span class="hljs-built_in">modify</span>(u &lt;&lt; <span class="hljs-number">1</span>, pos, x);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">modify</span>(u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, pos, x);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query_rk</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> x)</span><span class="hljs-comment">//查询共有多少个小于给定数值的，排名要+1</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(l &lt;= L[u] &amp;&amp; R[u] &lt;= r) <span class="hljs-keyword">return</span> <span class="hljs-built_in">get_k</span>(T[u], x) - <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-type">int</span> mid = L[u] + R[u] &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(l &lt;= mid) res += <span class="hljs-built_in">query_rk</span>(u &lt;&lt; <span class="hljs-number">1</span>, l, r, x);<br>    <span class="hljs-keyword">if</span>(r &gt; mid) res += <span class="hljs-built_in">query_rk</span>(u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, l, r, x);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query_pre</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> x)</span><span class="hljs-comment">//找数值前驱</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(l &lt;= L[u] &amp;&amp; R[u] &lt;= r)&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-built_in">get_pre</span>(T[u], x);<br>        <span class="hljs-keyword">return</span> tr[res].v;<br>    &#125;<br><br>    <span class="hljs-type">int</span> mid = L[u] + R[u] &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> res = -INF;<br>    <span class="hljs-keyword">if</span>(l &lt;= mid) res = <span class="hljs-built_in">max</span>(res, <span class="hljs-built_in">query_pre</span>(u &lt;&lt; <span class="hljs-number">1</span>, l, r, x));<br>    <span class="hljs-keyword">if</span>(r &gt; mid) res = <span class="hljs-built_in">max</span>(res, <span class="hljs-built_in">query_pre</span>(u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, l, r, x));<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query_suc</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> x)</span><span class="hljs-comment">//找数值后继</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(l &lt;= L[u] &amp;&amp; R[u] &lt;= r)&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-built_in">get_suc</span>(T[u], x);<br>        <span class="hljs-keyword">return</span> tr[res].v;<br>    &#125;<br><br>    <span class="hljs-type">int</span> mid = L[u] + R[u] &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> res = INF;<br>    <span class="hljs-keyword">if</span>(l &lt;= mid) res = <span class="hljs-built_in">min</span>(res, <span class="hljs-built_in">query_suc</span>(u &lt;&lt; <span class="hljs-number">1</span>, l, r, x));<br>    <span class="hljs-keyword">if</span>(r &gt; mid) res = <span class="hljs-built_in">min</span>(res, <span class="hljs-built_in">query_suc</span>(u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, l, r, x));<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>        cin &gt;&gt; a[i];<br><br>    <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n);<br><br>    <span class="hljs-keyword">while</span>(m --)&#123;<br>        <span class="hljs-type">int</span> op, pos, l, r, x;<br>        cin &gt;&gt; op;<br>        <br>        <span class="hljs-keyword">if</span>(op == <span class="hljs-number">1</span>)&#123;<br>            cin &gt;&gt; l &gt;&gt; r &gt;&gt; x;<br>            cout &lt;&lt; <span class="hljs-built_in">query_rk</span>(<span class="hljs-number">1</span>, l, r, x) + <span class="hljs-number">1</span> &lt;&lt; endl;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op == <span class="hljs-number">2</span>)&#123;<br>            cin &gt;&gt; l &gt;&gt; r &gt;&gt; x;<br>            <span class="hljs-type">int</span> ls = <span class="hljs-number">0</span>, rs = <span class="hljs-number">1e8</span>;<br>            <span class="hljs-keyword">while</span>(ls &lt; rs)&#123;<br>                <span class="hljs-type">int</span> mid = ls + rs + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">query_rk</span>(<span class="hljs-number">1</span>, l, r, mid) + <span class="hljs-number">1</span> &lt;= x) ls = mid;<br>                <span class="hljs-keyword">else</span> rs = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>            cout &lt;&lt; rs &lt;&lt; endl;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op == <span class="hljs-number">3</span>)&#123;<br>            cin &gt;&gt; pos &gt;&gt; x;<br>            <span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, pos, x);<br>            a[pos] = x;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op == <span class="hljs-number">4</span>)&#123;<br>            cin &gt;&gt; l &gt;&gt; r &gt;&gt; x;<br>            cout &lt;&lt; <span class="hljs-built_in">query_pre</span>(<span class="hljs-number">1</span>, l, r, x) &lt;&lt; endl;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op == <span class="hljs-number">5</span>)&#123;<br>            cin &gt;&gt; l &gt;&gt; r &gt;&gt; x;<br>            cout &lt;&lt; <span class="hljs-built_in">query_suc</span>(<span class="hljs-number">1</span>, l, r, x) &lt;&lt; endl;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>线段树套线段树(外层权值线段树，内层动态开点)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">AcWing 2306.K大数查询</span><br><span class="hljs-comment">有 N 个位置，M 个操作。每个位置可以同时存储多个数。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">操作有两种，每次操作:</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">如果是 1 a b c 的形式，表示在第 a 个位置到第 b 个位置，每个位置加入一个数 c。</span><br><span class="hljs-comment">如果是 2 a b c 的形式，表示询问从第 a 个位置到第 b 个位置，第 c 大的数是多少。</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">50010</span>, M = N * <span class="hljs-number">400</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>    <span class="hljs-type">int</span> lc, rc;<br>    <span class="hljs-type">int</span> sum, add;<br>&#125;tr[M];<br><span class="hljs-type">int</span> L[N &lt;&lt; <span class="hljs-number">2</span>], R[N &lt;&lt; <span class="hljs-number">2</span>], T[N &lt;&lt; <span class="hljs-number">2</span>], idx;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">query</span>&#123;<br>    <span class="hljs-type">int</span> op, a, b, c;<br>&#125;q[N];<br>vector&lt;<span class="hljs-type">int</span>&gt; hs;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">lower_bound</span>(hs.<span class="hljs-built_in">begin</span>(), hs.<span class="hljs-built_in">end</span>(), x) - hs.<span class="hljs-built_in">begin</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mixed</span><span class="hljs-params">(<span class="hljs-type">int</span> l1, <span class="hljs-type">int</span> r1, <span class="hljs-type">int</span> l2, <span class="hljs-type">int</span> r2)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(r2, r1) - <span class="hljs-built_in">max</span>(l2, l1) + <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">//内层线段树，动态开点，只开用到的点, 标记可持久化</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> ml, <span class="hljs-type">int</span> mr)</span><span class="hljs-comment">//更新内层线段树</span></span><br><span class="hljs-function"></span>&#123;<br>    tr[u].sum += <span class="hljs-built_in">mixed</span>(l, r, ml, mr);<br>    <span class="hljs-keyword">if</span>(ml &lt;= l &amp;&amp; r &lt;= mr)&#123;<br>        tr[u].add ++;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(ml &lt;= mid)&#123; <br>        <span class="hljs-keyword">if</span>(!tr[u].lc) tr[u].lc = ++ idx;<br>        <span class="hljs-built_in">update</span>(tr[u].lc, l, mid, ml, mr);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(mr &gt; mid)&#123;<br>        <span class="hljs-keyword">if</span>(!tr[u].rc) tr[u].rc = ++ idx;<br>        <span class="hljs-built_in">update</span>(tr[u].rc, mid + <span class="hljs-number">1</span>, r, ml, mr);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_sum</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> ml, <span class="hljs-type">int</span> mr, <span class="hljs-type">int</span> add)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(ml &lt;= l &amp;&amp; r &lt;= mr) <span class="hljs-keyword">return</span> tr[u].sum + (r - l + <span class="hljs-number">1</span>) * add;<br><br>    <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>    add += tr[u].add;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(ml &lt;= mid)&#123;<br>        <span class="hljs-keyword">if</span>(tr[u].lc) res += <span class="hljs-built_in">get_sum</span>(tr[u].lc, l, mid, ml, mr, add);<br>        <span class="hljs-keyword">else</span> res += <span class="hljs-built_in">mixed</span>(l, mid, ml, mr) * add;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(mr &gt; mid)&#123; <br>        <span class="hljs-keyword">if</span>(tr[u].rc) res += <span class="hljs-built_in">get_sum</span>(tr[u].rc, mid + <span class="hljs-number">1</span>, r, ml, mr, add);<br>        <span class="hljs-keyword">else</span> res += <span class="hljs-built_in">mixed</span>(mid + <span class="hljs-number">1</span>, r, ml, mr) * add;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">//外层线段树， 权值线段树</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    L[u] = l, R[u] = r, T[u] = ++ idx;<br>    <span class="hljs-keyword">if</span>(l == r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">build</span>(u &lt;&lt; <span class="hljs-number">1</span>, l, mid), <span class="hljs-built_in">build</span>(u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">update</span>(T[u], <span class="hljs-number">1</span>, n, l, r);<br>    <span class="hljs-keyword">if</span>(L[u] == R[u]) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> mid = L[u] + R[u] &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(c &lt;= mid) <span class="hljs-built_in">modify</span>(u &lt;&lt; <span class="hljs-number">1</span>, l, r, c);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">modify</span>(u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, l, r, c);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(L[u] == R[u]) <span class="hljs-keyword">return</span> R[u];<br>    <span class="hljs-type">int</span> mid = L[u] + R[u] &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> k = <span class="hljs-built_in">get_sum</span>(T[u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>], <span class="hljs-number">1</span>, n, l, r, <span class="hljs-number">0</span>);<span class="hljs-comment">//右子树里有多少在l,r内的权值</span><br>    <span class="hljs-keyword">if</span>(k &gt;= c) <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, l, r, c);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(u &lt;&lt; <span class="hljs-number">1</span>, l, r, c - k);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i ++)&#123;<br>        <span class="hljs-type">int</span> op, a, b, c;<br>        cin &gt;&gt; op &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br>        q[i] = &#123;op, a, b, c&#125;;<br>        <span class="hljs-keyword">if</span>(op == <span class="hljs-number">1</span>) hs.<span class="hljs-built_in">push_back</span>(c);<br>    &#125;<br><br>    <span class="hljs-comment">//数值离散化</span><br>    <span class="hljs-built_in">sort</span>(hs.<span class="hljs-built_in">begin</span>(), hs.<span class="hljs-built_in">end</span>());<br>    hs.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(hs.<span class="hljs-built_in">begin</span>(), hs.<span class="hljs-built_in">end</span>()), hs.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, (<span class="hljs-type">int</span>)hs.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i ++)&#123;<br>        <span class="hljs-type">int</span> op = q[i].op, a = q[i].a, b = q[i].b, c = q[i].c;<br>        <span class="hljs-keyword">if</span>(op == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, a, b, <span class="hljs-built_in">get</span>(c));<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            cout &lt;&lt; hs[<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, a, b, c)] &lt;&lt; endl;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="分块"><a href="#分块" class="headerlink" title="分块"></a>分块</h2><p>思想把整个区间分成$sqrt(n)$个小区间，对于整个包含于查询或修改的小区间，标记或直接询问，对于部分包含于查询或修改区间的小区间直接暴力</p><p>整个包含的小区间不超过$sqrt(n)$个， 暴力修改或查询的点也是$sqrt(n)$ 级别，这样单次总复杂度就是$O(sqrt(n))$.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">AcWing 243.一个简单的整数问题2</span><br><span class="hljs-comment">给定一个长度为 N 的数列 A，以及 M 条指令，每条指令可能是以下两种之一：</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">C l r d，表示把 A[l],A[l+1],…,A[r] 都加上 d。</span><br><span class="hljs-comment">Q l r，表示询问数列中第 l∼r 个数的和。</span><br><span class="hljs-comment">对于每个询问，输出一个整数表示答案。</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> LL = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>, M = <span class="hljs-number">350</span>;<br>LL add[M], sum[M];<br><span class="hljs-type">int</span> a[N];<br><span class="hljs-type">int</span> n, m, len;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> (x - <span class="hljs-number">1</span>) / len;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> d)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">get</span>(l) == <span class="hljs-built_in">get</span>(r))&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = l; i &lt;= r; i ++) a[i] += d, sum[<span class="hljs-built_in">get</span>(i)] += d;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-type">int</span> i = l, j = r;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-built_in">get</span>(i) == <span class="hljs-built_in">get</span>(l)) a[i] += d, sum[<span class="hljs-built_in">get</span>(i)] += d, i ++;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-built_in">get</span>(j) == <span class="hljs-built_in">get</span>(r)) a[j] += d, sum[<span class="hljs-built_in">get</span>(j)] += d, j --;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-built_in">get</span>(i); k &lt;= <span class="hljs-built_in">get</span>(j); k ++) add[k] += d, sum[k] += <span class="hljs-number">1ll</span> * len * d;<br>    &#125;<br>&#125;<br><br><span class="hljs-function">LL <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    LL res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">get</span>(l) == <span class="hljs-built_in">get</span>(r))&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = l; i &lt;= r; i ++) res += a[i] + add[<span class="hljs-built_in">get</span>(i)];<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-type">int</span> i = l, j = r;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-built_in">get</span>(i) == <span class="hljs-built_in">get</span>(l)) res += a[i] + add[<span class="hljs-built_in">get</span>(i)], i ++;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-built_in">get</span>(j) == <span class="hljs-built_in">get</span>(r)) res += a[j] + add[<span class="hljs-built_in">get</span>(j)], j --;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-built_in">get</span>(i); k &lt;= <span class="hljs-built_in">get</span>(j); k ++) res += sum[k];<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><br>    cin &gt;&gt; n &gt;&gt; m;<br>    len = <span class="hljs-built_in">sqrt</span>(n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)&#123;<br>        cin &gt;&gt; a[i];<br>        sum[<span class="hljs-built_in">get</span>(i)] += a[i];<br>    &#125;<br><br>    <span class="hljs-type">char</span> op[<span class="hljs-number">2</span>];<br>    <span class="hljs-type">int</span> l, r, d;<br>    <span class="hljs-keyword">while</span>(m --)&#123;<br>        cin &gt;&gt; op;<br>        <span class="hljs-keyword">if</span>(op[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;Q&#x27;</span>)&#123;<br>            cin &gt;&gt; l &gt;&gt; r;<br>            cout &lt;&lt; <span class="hljs-built_in">query</span>(l, r) &lt;&lt; endl;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            cin &gt;&gt; l &gt;&gt; r &gt;&gt; d;<br>            <span class="hljs-built_in">change</span>(l, r, d);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="莫队"><a href="#莫队" class="headerlink" title="莫队"></a>莫队</h2><ul><li><p>基础莫队</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">AcWing.2492.HH的项链</span><br><span class="hljs-comment">HH 有一串由各种漂亮的贝壳组成的项链。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">HH 相信不同的贝壳会带来好运，所以每次散步完后，他都会随意取出一段贝壳，思考它们所表达的含义。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">HH 不断地收集新的贝壳，因此他的项链变得越来越长。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">有一天，他突然提出了一个问题：某一段贝壳中，包含了多少种不同的贝壳？</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">这个问题很难回答，因为项链实在是太长了。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">于是，他只好求助睿智的你，来解决这个问题。</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">50010</span>, M = <span class="hljs-number">200010</span>;<br><span class="hljs-type">int</span> a[N];<br><span class="hljs-type">int</span> cnt[<span class="hljs-number">1000010</span>];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">query</span>&#123;<br>    <span class="hljs-type">int</span> id, l, r;<br>&#125;qr[M];<br><span class="hljs-type">int</span> ans[M];<br><span class="hljs-type">int</span> n, m, len;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> x / len;<br>&#125;<br><br><span class="hljs-comment">//在同一块内，右端点递增排序，不同块内，块递增排序</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> query &amp;a, <span class="hljs-type">const</span> query &amp;b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-built_in">get</span>(a.l), j = <span class="hljs-built_in">get</span>(b.l);<br>    <span class="hljs-keyword">if</span>(i != j) <span class="hljs-keyword">return</span> i &lt; j;<br>    <span class="hljs-keyword">return</span> a.r &lt; b.r;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> &amp;res)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(++ cnt[x] == <span class="hljs-number">1</span>) res ++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sub</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> &amp;res)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(-- cnt[x] == <span class="hljs-number">0</span>) res --;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><br>    cin &gt;&gt; n;<br>    len = <span class="hljs-built_in">sqrt</span>(n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>        cin &gt;&gt; a[i];<br><br>    cin &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i ++)&#123;<br>        <span class="hljs-type">int</span> l, r;<br>        cin &gt;&gt; l &gt;&gt; r;<br>        qr[i] = &#123;i, l, r&#125;;<br>    &#125;<br><br>    <span class="hljs-built_in">sort</span>(qr + <span class="hljs-number">1</span>, qr + <span class="hljs-number">1</span> + m, cmp);<br>    <br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">1</span>, res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= m; k ++)&#123;<br>        <span class="hljs-type">int</span> id = qr[k].id, l = qr[k].l, r = qr[k].r;<br>        <span class="hljs-comment">//注意先加减还是后加减</span><br>        <span class="hljs-keyword">while</span>(i &lt; r) <span class="hljs-built_in">add</span>(a[++ i], res);<br>        <span class="hljs-keyword">while</span>(i &gt; r) <span class="hljs-built_in">sub</span>(a[i --], res);<br>        <span class="hljs-keyword">while</span>(j &gt; l) <span class="hljs-built_in">add</span>(a[-- j], res);<br>        <span class="hljs-keyword">while</span>(j &lt; l) <span class="hljs-built_in">sub</span>(a[j ++], res);<br>        ans[id] = res;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i ++)<br>        cout &lt;&lt; ans[i] &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>带修莫队</p><p>分块的大小为$\sqrt[3]{n<em>t}$,  可以达到最块理论复杂度$O(\sqrt[3]{n^4</em>t})$ , t 为修改次数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">AcWing 2521. 数颜色</span><br><span class="hljs-comment">墨墨购买了一套 N 支彩色画笔（其中有些颜色可能相同），摆成一排，你需要回答墨墨的提问。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">墨墨会像你发布如下指令：</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Q L R 代表询问你从第 L 支画笔到第 R 支画笔中共有几种不同颜色的画笔。</span><br><span class="hljs-comment">R P Col 把第 P 支画笔替换为颜色 Col。</span><br><span class="hljs-comment">为了满足墨墨的要求，你知道你需要干什么了吗？</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">10010</span>, M = <span class="hljs-number">1000010</span>;<br><span class="hljs-type">int</span> cnt[M];<br><span class="hljs-type">int</span> a[N], ans[N];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">query</span>&#123;<br>    <span class="hljs-type">int</span> id, l, r, t;<br>&#125;qr[N];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">change</span>&#123;<br>    <span class="hljs-type">int</span> p, x;<br>&#125;cg[N];<br><span class="hljs-type">int</span> n, m, mq, mc, len;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> x / len;<br>&#125;<br><br><span class="hljs-comment">//按照左端点所在块编号，右端点所在块编号，第几个修改版本三关键字排序</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> query &amp;a, <span class="hljs-type">const</span> query &amp;b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> al = <span class="hljs-built_in">get</span>(a.l), ar = <span class="hljs-built_in">get</span>(a.r);<br>    <span class="hljs-type">int</span> bl = <span class="hljs-built_in">get</span>(b.l), br = <span class="hljs-built_in">get</span>(b.r);<br>    <span class="hljs-keyword">if</span>(al != bl) <span class="hljs-keyword">return</span> al &lt; bl;<br>    <span class="hljs-keyword">if</span>(ar != br) <span class="hljs-keyword">return</span> ar &lt; br;<br>    <span class="hljs-keyword">return</span> a.t &lt; b.t;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> &amp;res)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(++ cnt[x] == <span class="hljs-number">1</span>) res ++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sub</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> &amp;res)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(-- cnt[x] == <span class="hljs-number">0</span>) res --;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>        cin &gt;&gt; a[i];<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i ++)&#123;<br>        <span class="hljs-type">char</span> op[<span class="hljs-number">2</span>];<br>        <span class="hljs-type">int</span> l, r;<br>        cin &gt;&gt; op &gt;&gt; l &gt;&gt; r;<br>        <span class="hljs-keyword">if</span>(op[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;Q&#x27;</span>)&#123;<br>            mq ++, qr[mq] = &#123;mq, l, r, mc&#125;;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            cg[++ mc] = &#123;l, r&#125;;<br>        &#125;<br>    &#125;<br>    len = <span class="hljs-built_in">cbrt</span>(<span class="hljs-number">1.0</span> * n * <span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>, mc)) + <span class="hljs-number">1</span>;<br><br>    <span class="hljs-built_in">sort</span>(qr + <span class="hljs-number">1</span>, qr + <span class="hljs-number">1</span> + mq, cmp);<br><br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">1</span>, t = <span class="hljs-number">0</span>, res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= mq; k ++)&#123;<br>        <span class="hljs-type">int</span> id = qr[k].id, l = qr[k].l, r = qr[k].r, tq = qr[k].t;<br>        <span class="hljs-keyword">while</span>(i &lt; r) <span class="hljs-built_in">add</span>(a[++ i], res);<br>        <span class="hljs-keyword">while</span>(i &gt; r) <span class="hljs-built_in">sub</span>(a[i --], res);<br>        <span class="hljs-keyword">while</span>(j &gt; l) <span class="hljs-built_in">add</span>(a[-- j], res);<br>        <span class="hljs-keyword">while</span>(j &lt; l) <span class="hljs-built_in">sub</span>(a[j ++], res);<br>        <span class="hljs-keyword">while</span>(t &lt; tq)&#123;<br>            t ++;<br>            <span class="hljs-type">int</span> p = cg[t].p, &amp;x = cg[t].x;<br>            <span class="hljs-keyword">if</span>(j &lt;= p &amp;&amp; p &lt;= i)&#123;<br>                <span class="hljs-built_in">sub</span>(a[p], res);<br>                <span class="hljs-built_in">add</span>(x, res);<br>            &#125;<br>            <span class="hljs-built_in">swap</span>(x, a[p]);<br>        &#125;<br>        <span class="hljs-keyword">while</span>(t &gt; tq)&#123;<br>            <span class="hljs-type">int</span> p = cg[t].p, &amp;x = cg[t].x;<br>            <span class="hljs-keyword">if</span>(j &lt;= p &amp;&amp; p &lt;= i)&#123;<br>                <span class="hljs-built_in">sub</span>(a[p], res);<br>                <span class="hljs-built_in">add</span>(x, res);<br>            &#125;<br>            <span class="hljs-built_in">swap</span>(x, a[p]);<br>            t --;<br>        &#125;<br>        ans[id] = res;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= mq; i ++)<br>        cout &lt;&lt; ans[i] &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>回滚莫队<br>对于每个分块，在块内的查询暴力做，块间的按照右端点排序，依次查询，每次查询要把前一次查询在块内的部分回滚掉</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">AcWing 2523.历史研究</span><br><span class="hljs-comment">IOI 国历史研究的第一人——JOI 教授，最近获得了一份被认为是古代 IOI 国的住民写下的日记。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">JOI 教授为了通过这份日记来研究古代 IOI 国的生活，开始着手调查日记中记载的事件。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">日记中记录了连续 N 天发生的时间，大约每天发生一件。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">事件有种类之分。第 i 天 (1≤i≤N) 发生的事件的种类用一个整数 Xi 表示，Xi 越大，事件的规模就越大。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">JOI 教授决定用如下的方法分析这些日记：</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">选择日记中连续的一些天作为分析的时间段</span><br><span class="hljs-comment">事件种类 t 的重要度为 t× (这段时间内重要度为 t 的事件数)</span><br><span class="hljs-comment">计算出所有事件种类的重要度，输出其中的最大值</span><br><span class="hljs-comment">现在你被要求制作一个帮助教授分析的程序，每次给出分析的区间，你需要输出重要度的最大值。</span><br><span class="hljs-comment">数据范围1e5</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> LL = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> a[N], cnt[N];<br>LL ans[N];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">query</span>&#123;<br>    <span class="hljs-type">int</span> id, l, r;<br>&#125;qr[N];<br><span class="hljs-type">int</span> n, m, len;<br>vector&lt;<span class="hljs-type">int</span>&gt; hs;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> x / len;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> query &amp;a, <span class="hljs-type">const</span> query &amp;b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-built_in">get</span>(a.l), j = <span class="hljs-built_in">get</span>(b.l);<br>    <span class="hljs-keyword">if</span>(i != j) <span class="hljs-keyword">return</span> i &lt; j;<br>    <span class="hljs-keyword">return</span> a.r &lt; b.r;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, LL &amp;res)</span></span><br><span class="hljs-function"></span>&#123;<br>    cnt[x] ++;<br>    res = <span class="hljs-built_in">max</span>(res, <span class="hljs-number">1ll</span> * cnt[x] * hs[x]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><br>    cin &gt;&gt; n &gt;&gt; m;<br>    len = <span class="hljs-built_in">sqrt</span>(n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)&#123;<br>        cin &gt;&gt; a[i];<br>        hs.<span class="hljs-built_in">push_back</span>(a[i]);<br>    &#125;<br><br>    <span class="hljs-built_in">sort</span>(hs.<span class="hljs-built_in">begin</span>(), hs.<span class="hljs-built_in">end</span>());<br>    hs.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(hs.<span class="hljs-built_in">begin</span>(), hs.<span class="hljs-built_in">end</span>()), hs.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>        a[i] = <span class="hljs-built_in">lower_bound</span>(hs.<span class="hljs-built_in">begin</span>(), hs.<span class="hljs-built_in">end</span>(), a[i]) - hs.<span class="hljs-built_in">begin</span>();<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i ++)&#123;<br>        <span class="hljs-type">int</span> l, r;<br>        cin &gt;&gt; l &gt;&gt; r;<br>        qr[i] = &#123;i, l, r&#125;;<br>    &#125;<br><br>    <span class="hljs-built_in">sort</span>(qr + <span class="hljs-number">1</span>, qr + <span class="hljs-number">1</span> + m, cmp);<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x = <span class="hljs-number">1</span>; x &lt;= m;)&#123;<br>        <span class="hljs-type">int</span> y = x;<br>        <span class="hljs-keyword">while</span>(y &lt;= m &amp;&amp; <span class="hljs-built_in">get</span>(qr[y].l) == <span class="hljs-built_in">get</span>(qr[x].l)) y ++;<br>        <span class="hljs-type">int</span> right = <span class="hljs-built_in">get</span>(qr[x].l) * len + len - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">//处理块内询问</span><br>        <span class="hljs-keyword">while</span>(x &lt; y &amp;&amp; qr[x].r &lt;= right)&#123;<br>            LL res = <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> id = qr[x].id, l = qr[x].l, r = qr[x].r;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = l; k &lt;= r; k ++) <span class="hljs-built_in">add</span>(a[k], res);<br>            ans[id] = res;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = l; k &lt;= r; k ++) cnt[a[k]] --;<br>            x ++;<br>        &#125;<br><br>        <span class="hljs-comment">//处理块间询问</span><br>        LL res = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> i = right, j = right + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(x &lt; y)&#123;<br>            <span class="hljs-type">int</span> id = qr[x].id, l = qr[x].l, r = qr[x].r;<br>            <span class="hljs-keyword">while</span>(i &lt; r) <span class="hljs-built_in">add</span>(a[++ i], res);<br>            LL backup = res;<br>            <span class="hljs-keyword">while</span>(j &gt; l) <span class="hljs-built_in">add</span>(a[-- j], res);<br>            ans[id] = res;<br>            <span class="hljs-keyword">while</span>(j &lt; right + <span class="hljs-number">1</span>) cnt[a[j ++]] --;<br>            res = backup;<br>            x ++;<br>        &#125;<br>        <span class="hljs-built_in">memset</span>(cnt, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(cnt));<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i ++)<br>        cout &lt;&lt; ans[i] &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>树上莫队</p><ul><li>核心：把树上路径转化为序列，通常转化为欧拉序列</li><li>欧拉序列：dfs遍历一个树，第一次遍历到一个点时，把其加入序列，回溯时再把其加入序列，得到就是欧拉序列</li><li>性质：对于a, b两个点 $first[a] &lt; first[b]$<ul><li>若$lca(a, b) &#x3D; a$ 则对应的序列中的区间为$first[a] \approx fisrt[b]$</li><li>若$lca(a, b) \neq a$ 则对应的序列中的区间为$last[a] \approx firat[b] + lca(a, b)$</li></ul></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">AcWing 2534.树上计数2</span><br><span class="hljs-comment">给定一棵 N 个节点的树，节点编号从 1 到 N，每个节点都有一个整数权值。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">现在，我们要进行 M 次询问，格式为 u v，对于每个询问你需要回答从 u 到 v 的路径上（包括两端点）共有多少种不同的点权值。</span><br><span class="hljs-comment">1≤N≤40000,</span><br><span class="hljs-comment">1≤M≤105,</span><br><span class="hljs-comment">1≤x,y,u,v≤N,</span><br><span class="hljs-comment">各点权值均在 int 范围内。</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> h[N], e[N], ne[N], idx;<br><span class="hljs-type">int</span> seq[N], top;<br><span class="hljs-type">int</span> first[N], last[N];<br><span class="hljs-type">int</span> depth[N], f[N][<span class="hljs-number">16</span>];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">query</span>&#123;<br><span class="hljs-type">int</span> id, l, r, p;<br>&#125;qr[N];<br><span class="hljs-type">int</span> a[N], ans[N], cnt[N];<br><span class="hljs-type">bool</span> st[N];<br><span class="hljs-type">int</span> n, m, len;<br>vector&lt;<span class="hljs-type">int</span>&gt; hs;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> edge)</span></span><br><span class="hljs-function"></span>&#123;<br>e[idx] = b, ne[idx] = h[a], h[a] = idx ++;<br>e[idx] = a, ne[idx] = h[b], h[b] = idx ++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> fa)</span></span><br><span class="hljs-function"></span>&#123;<br>seq[++ top] = u;<br>first[u] = top;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[u]; ~i; i = ne[i])&#123;<br><span class="hljs-type">int</span> ver = e[i];<br><span class="hljs-keyword">if</span>(ver == fa) <span class="hljs-keyword">continue</span>;<br><span class="hljs-built_in">dfs</span>(ver, u);<br>&#125;<br>seq[++ top] = u;<br>last[u] = top;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> q[N] = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">int</span> hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">0</span>;<br>q[<span class="hljs-number">0</span>] = &#123;<span class="hljs-number">1</span>&#125;;<br><span class="hljs-built_in">memset</span>(depth, <span class="hljs-number">0x3f</span>, <span class="hljs-built_in">sizeof</span>(depth));<br>depth[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>, depth[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">while</span>(hh &lt;= tt)&#123;<br><span class="hljs-type">int</span> t = q[hh ++];<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[t]; ~i; i = ne[i])&#123;<br><span class="hljs-type">int</span> ver = e[i];<br><span class="hljs-keyword">if</span>(depth[ver] &gt; depth[t] + <span class="hljs-number">1</span>)&#123;<br>depth[ver] = depth[t] + <span class="hljs-number">1</span>;<br>f[ver][<span class="hljs-number">0</span>] = t;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= <span class="hljs-number">15</span>; k ++)<br>f[ver][k] = f[f[ver][k - <span class="hljs-number">1</span>]][k - <span class="hljs-number">1</span>];<br>q[++ tt] = ver;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(depth[a] &lt; depth[b]) <span class="hljs-built_in">swap</span>(a, b);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">15</span>; k &gt;= <span class="hljs-number">0</span>; k --)<br><span class="hljs-keyword">if</span>(depth[f[a][k]] &gt;= depth[b])<br>a = f[a][k];<br><span class="hljs-keyword">if</span>(a == b) <span class="hljs-keyword">return</span> a;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">15</span>; k &gt;= <span class="hljs-number">0</span>; k --)<br><span class="hljs-keyword">if</span>(f[a][k] != f[b][k])&#123;<br>a = f[a][k];<br>b = f[b][k];<br>&#125;<br><span class="hljs-keyword">return</span> f[a][<span class="hljs-number">0</span>];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> x / len;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> query &amp;a, <span class="hljs-type">const</span> query &amp;b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> i = <span class="hljs-built_in">get</span>(a.l), j = <span class="hljs-built_in">get</span>(b.l);<br><span class="hljs-keyword">if</span>(i != j) <span class="hljs-keyword">return</span> i &lt; j;<br><span class="hljs-keyword">return</span> a.r &lt; b.r;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> &amp;res)</span></span><br><span class="hljs-function"></span>&#123;<br>st[x] ^= <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(st[x])&#123;<br><span class="hljs-keyword">if</span>(++ cnt[a[x]] == <span class="hljs-number">1</span>) res ++;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">if</span>(-- cnt[a[x]] == <span class="hljs-number">0</span>) res --;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><br>cin &gt;&gt; n &gt;&gt; m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)&#123;<br>cin &gt;&gt; a[i];<br>hs.<span class="hljs-built_in">push_back</span>(a[i]);<br>&#125;<br><br><span class="hljs-built_in">sort</span>(hs.<span class="hljs-built_in">begin</span>(), hs.<span class="hljs-built_in">end</span>());<br>hs.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(hs.<span class="hljs-built_in">begin</span>(), hs.<span class="hljs-built_in">end</span>()), hs.<span class="hljs-built_in">end</span>());<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>a[i] = <span class="hljs-built_in">lower_bound</span>(hs.<span class="hljs-built_in">begin</span>(), hs.<span class="hljs-built_in">end</span>(), a[i]) - hs.<span class="hljs-built_in">begin</span>();<br><br><span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(h));<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i ++)&#123;<br><span class="hljs-type">int</span> x, y;<br>cin &gt;&gt; x &gt;&gt; y;<br><span class="hljs-built_in">add</span>(x, y, <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">//预处理欧拉序、 lca</span><br><span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);<br><span class="hljs-built_in">bfs</span>();<br><br>len = <span class="hljs-built_in">sqrt</span>(top);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i ++)&#123;<br><span class="hljs-type">int</span> a, b;<br>cin &gt;&gt; a &gt;&gt; b;<br><span class="hljs-keyword">if</span>(first[a] &gt; first[b]) <span class="hljs-built_in">swap</span>(a, b);<br><span class="hljs-type">int</span> p = <span class="hljs-built_in">lca</span>(a, b);<br><span class="hljs-keyword">if</span>(a == p) qr[i] = &#123;i, first[a], first[b]&#125;;<br><span class="hljs-keyword">else</span> qr[i] = &#123;i, last[a], first[b], p&#125;;<br>&#125;<br><br><span class="hljs-built_in">sort</span>(qr + <span class="hljs-number">1</span>, qr + <span class="hljs-number">1</span> + m, cmp);<br><br><span class="hljs-comment">//莫队</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">1</span>, res = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= m; k ++)&#123;<br><span class="hljs-type">int</span> id = qr[k].id, l = qr[k].l, r = qr[k].r, p = qr[k].p;<br><span class="hljs-keyword">while</span>(i &lt; r) <span class="hljs-built_in">add</span>(seq[++ i], res);<br><span class="hljs-keyword">while</span>(i &gt; r) <span class="hljs-built_in">add</span>(seq[i --], res);<br><span class="hljs-keyword">while</span>(j &gt; l) <span class="hljs-built_in">add</span>(seq[-- j], res);<br><span class="hljs-keyword">while</span>(j &lt; l) <span class="hljs-built_in">add</span>(seq[j ++], res);<br><span class="hljs-keyword">if</span>(p) <span class="hljs-built_in">add</span>(p, res);<br>ans[id] = res;<br><span class="hljs-keyword">if</span>(p) <span class="hljs-built_in">add</span>(p, res); <br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i ++)<br>cout &lt;&lt; ans[i] &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="树链剖分"><a href="#树链剖分" class="headerlink" title="树链剖分"></a>树链剖分</h2><ul><li>概念<ul><li>重儿子：一个节点的儿子所在子树中节点个数最多的儿子</li><li>轻儿子：除了重儿子外的其他儿子</li><li>重边：连接父节点和重儿子的边</li><li>轻边：连接父节点和轻儿子的边</li><li>重链：由所有重边组成的边，每个点一定在一个重链中，单个节点也可构成重链</li></ul></li><li>如何解决树上问题<ul><li>将一颗树转化为序列，采用优先遍历重儿子的方式dfs, 保证重链在序列中连续</li><li>树中路径转化为$logn$个的连续区间（重链），采用线段树等数据结构维护信息即可</li></ul></li><li>性质<ul><li>定理：树中任意一条路径都可以转化为$logn$个连续区间（重链）</li><li>证明：考虑极端情况，从根节点走到任意叶节点，走过的重链数量等于走过的轻边数量，每走过一个轻边，子树大小至少减小二分之一，因此从根节点走到叶子节点最多都$logn$条轻边，即最多走过$logn$个重链，即走过$logn$个连续区间</li></ul></li><li>tips<ul><li>点权转边权：把边权转到子节点上即可，除了根节点，其他节点上都是权值，此时修改和查询不能计算路径上最高的节点。</li></ul></li><li>时间复杂度<ul><li>最坏的操作为用线段树每个维护$logn$个连续区间，因此时间复杂度为$O(n*(logn)^2)$</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">AcWing2568.树链剖分</span><br><span class="hljs-comment">给定一棵树，树中包含 n 个节点（编号 1∼n），其中第 i 个节点的权值为 ai。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">初始时，1 号节点为树的根节点。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">现在要对该树进行 m 次操作，操作分为以下 4 种类型：</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">1 u v k，修改路径上节点权值，将节点 u 和节点 v 之间路径上的所有节点（包括这两个节点）的权值增加 k。</span><br><span class="hljs-comment">2 u k，修改子树上节点权值，将以节点 u 为根的子树上的所有节点的权值增加 k。</span><br><span class="hljs-comment">3 u v，询问路径，询问节点 u 和节点 v 之间路径上的所有节点（包括这两个节点）的权值和。</span><br><span class="hljs-comment">4 u，询问子树，询问以节点 u 为根的子树上的所有节点的权值和。</span><br><span class="hljs-comment">数据范围</span><br><span class="hljs-comment">1≤n,m≤10^5,</span><br><span class="hljs-comment">0≤ai,k≤10^5,</span><br><span class="hljs-comment">1≤u,v,x,y≤n</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> LL = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>, M = N &lt;&lt; <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> a[N], id[N], na[N];<br><span class="hljs-type">int</span> h[N], e[M], ne[M], idx;<br><span class="hljs-type">int</span> depth[N], top[N], sz[N], fa[N], son[N], cnt;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>    <span class="hljs-type">int</span> l, r;<br>    LL add, sum;<br>&#125;tr[N &lt;&lt; <span class="hljs-number">2</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;<br>    e[idx] = a, ne[idx] = h[b], h[b] = idx ++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    tr[u].sum = tr[u &lt;&lt; <span class="hljs-number">1</span>].sum + tr[u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>].sum;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(node &amp;rt, node &amp;l, node &amp;r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(rt.add)&#123;<br>        l.add += rt.add, l.sum += (l.r - l.l + <span class="hljs-number">1</span>) * rt.add;<br>        r.add += rt.add, r.sum += (r.r - r.l + <span class="hljs-number">1</span>) * rt.add;<br>        rt.add = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">pushdown</span>(tr[u], tr[u &lt;&lt; <span class="hljs-number">1</span>], tr[u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(l == r)&#123;<br>        tr[u] = &#123;l, r, <span class="hljs-number">0</span>, na[l]&#125;;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    tr[u] = &#123;l, r&#125;;<br>    <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">build</span>(u &lt;&lt; <span class="hljs-number">1</span>, l, mid), <span class="hljs-built_in">build</span>(u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r);<br>    <span class="hljs-built_in">pushup</span>(u);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(l &lt;= tr[u].l &amp;&amp; tr[u].r &lt;= r)&#123;<br>        tr[u].add += k;<br>        tr[u].sum += (tr[u].r - tr[u].l + <span class="hljs-number">1</span>) * k;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">pushdown</span>(u);<br>    <span class="hljs-type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(l &lt;= mid) <span class="hljs-built_in">modify</span>(u &lt;&lt; <span class="hljs-number">1</span>, l, r, k);<br>    <span class="hljs-keyword">if</span>(r &gt; mid) <span class="hljs-built_in">modify</span>(u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, l, r, k);<br>    <span class="hljs-built_in">pushup</span>(u);<br>&#125;<br><br><span class="hljs-function">LL <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(l &lt;= tr[u].l &amp;&amp; tr[u].r &lt;= r) <span class="hljs-keyword">return</span> tr[u].sum;<br><br>    <span class="hljs-built_in">pushdown</span>(u);<br>    <span class="hljs-type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="hljs-number">1</span>;<br>    LL res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(l &lt;= mid) res += <span class="hljs-built_in">query</span>(u &lt;&lt; <span class="hljs-number">1</span>, l, r);<br>    <span class="hljs-keyword">if</span>(r &gt; mid) res += <span class="hljs-built_in">query</span>(u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, l, r);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> father, <span class="hljs-type">int</span> dep)</span></span><br><span class="hljs-function"></span>&#123;<br>    sz[u] = <span class="hljs-number">1</span>, depth[u] = dep, fa[u] = father ;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[u]; ~i; i = ne[i])&#123;<br>        <span class="hljs-type">int</span> ver = e[i];<br>        <span class="hljs-keyword">if</span>(ver == father) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-built_in">dfs1</span>(ver, u, dep + <span class="hljs-number">1</span>);<br>        sz[u] += sz[ver];<br>        <span class="hljs-keyword">if</span>(sz[son[u]] &lt; sz[ver]) son[u] = ver;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> t)</span></span><br><span class="hljs-function"></span>&#123;<br>    id[u] = ++ cnt, na[cnt] = a[u], top[u] = t;<br>    <span class="hljs-keyword">if</span>(!son[u]) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">dfs2</span>(son[u], t);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[u]; ~i; i = ne[i])&#123;<br>        <span class="hljs-type">int</span> ver = e[i];<br>        <span class="hljs-keyword">if</span>(ver == son[u] || ver == fa[u]) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-built_in">dfs2</span>(ver, ver);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify_path</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v, <span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span>(top[u] != top[v])&#123;<br>        <span class="hljs-keyword">if</span>(depth[top[u]] &lt; depth[top[v]]) <span class="hljs-built_in">swap</span>(u, v);<br>        <span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, id[top[u]], id[u], k);<br>        u = fa[top[u]];<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(depth[u] &lt; depth[v]) <span class="hljs-built_in">swap</span>(u, v);<br>    <span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, id[v], id[u], k);<br>&#125;<br><br><span class="hljs-function">LL <span class="hljs-title">query_path</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br>    LL res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(top[u] != top[v])&#123;<br>        <span class="hljs-keyword">if</span>(depth[top[u]] &lt; depth[top[v]]) <span class="hljs-built_in">swap</span>(u, v);<br>        res += <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, id[top[u]], id[u]);<br>        u = fa[top[u]];<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(depth[u] &lt; depth[v]) <span class="hljs-built_in">swap</span>(u, v);<br>    res += <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, id[v], id[u]);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify_tree</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, id[u], id[u] + sz[u] - <span class="hljs-number">1</span>, k);<br>&#125;<br><br><span class="hljs-function">LL <span class="hljs-title">query_tree</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, id[u], id[u] + sz[u] - <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>        cin &gt;&gt; a[i];<br><br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(h));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i ++)&#123;<br>        <span class="hljs-type">int</span> a, b;<br>        cin &gt;&gt; a &gt;&gt; b;<br>        <span class="hljs-built_in">add</span>(a, b);<br>    &#125;<br><br>    <span class="hljs-built_in">dfs1</span>(<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>);<span class="hljs-comment">//确定重边</span><br>    <span class="hljs-built_in">dfs2</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<span class="hljs-comment">//确定dfs序</span><br>    <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n);<br>    <br>    cin &gt;&gt; m;<br>    <span class="hljs-keyword">while</span>(m --)&#123;<br>        <span class="hljs-type">int</span> op, u, v, k;<br>        cin &gt;&gt; op;<br>        <span class="hljs-keyword">if</span>(op == <span class="hljs-number">1</span>)&#123;<br>            cin &gt;&gt; u &gt;&gt; v &gt;&gt; k;<br>            <span class="hljs-built_in">modify_path</span>(u, v, k);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op == <span class="hljs-number">2</span>)&#123;<br>            cin &gt;&gt; u &gt;&gt; k;<br>            <span class="hljs-built_in">modify_tree</span>(u, k);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op == <span class="hljs-number">3</span>)&#123;<br>            cin &gt;&gt; u &gt;&gt; v;<br>            cout &lt;&lt; <span class="hljs-built_in">query_path</span>(u, v) &lt;&lt; endl;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            cin &gt;&gt; u;<br>            cout &lt;&lt; <span class="hljs-built_in">query_tree</span>(u) &lt;&lt; endl;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="动态树"><a href="#动态树" class="headerlink" title="动态树"></a>动态树</h2><ul><li><p>思想：按照实边和虚边划分边，每个点一定在实边组成的链中，单个点自成链，每条实边链用一颗splay维护</p></li><li><p>tips:</p><ul><li>边权变点权技巧<ul><li>在两点之间插入一个点，并把边权赋在这个点上即可。</li></ul></li></ul></li><li><p>LCT七大操作</p><p><img src="/lct1.jpg" alt="lct1"></p></li></ul><p>​<img src="/lct2.jpg" alt="lct2"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">AcWing2539.动态树</span><br><span class="hljs-comment">给定 n 个点，编号从 1 到 n，其中第 i 个点的初始权值为 ai。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">现在要对这些点进行 m 次操作，操作共分为以下 4 种：</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">0 x y，表示询问点 x 到点 y 之间的路径上的所有点（包括两端点）的权值的异或和。保证 x 和 y 之间存在连通路径。</span><br><span class="hljs-comment">1 x y，表示在点 x 和点 y 之间增加一条边 (x,y)。注意：如果两点已经处于连通状态，则无视该操作。</span><br><span class="hljs-comment">2 x y，表示删除边 (x,y)。注意：如果该边不存在，则无视该操作。</span><br><span class="hljs-comment">3 x w，表示将点 x 的权值修改为 w。</span><br><span class="hljs-comment">数据范围</span><br><span class="hljs-comment">1≤n≤10^5,</span><br><span class="hljs-comment">1≤m≤3×10^5,</span><br><span class="hljs-comment">1≤x,y≤n,</span><br><span class="hljs-comment">x≠y,</span><br><span class="hljs-comment">1≤ai,w≤10^9</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>    <span class="hljs-type">int</span> s[<span class="hljs-number">2</span>], v, p;<br>    <span class="hljs-type">int</span> rev, sum;<br>&#125;tr[N];<br><span class="hljs-type">int</span> stk[N];<br><span class="hljs-type">int</span> n, m;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushrev</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    tr[x].rev ^= <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">swap</span>(tr[x].s[<span class="hljs-number">0</span>], tr[x].s[<span class="hljs-number">1</span>]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    tr[x].sum = tr[tr[x].s[<span class="hljs-number">0</span>]].sum ^ tr[x].v ^ tr[tr[x].s[<span class="hljs-number">1</span>]].sum;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(tr[x].rev)&#123;<br>        <span class="hljs-built_in">pushrev</span>(tr[x].s[<span class="hljs-number">0</span>]), <span class="hljs-built_in">pushrev</span>(tr[x].s[<span class="hljs-number">1</span>]);<br>        tr[x].rev = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_root</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> x != tr[tr[x].p].s[<span class="hljs-number">0</span>] &amp;&amp; x != tr[tr[x].p].s[<span class="hljs-number">1</span>];<br>&#125;<br><br><span class="hljs-comment">//splay函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> y = tr[x].p, z = tr[y].p;<br>    <span class="hljs-type">int</span> k = x == tr[y].s[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">is_root</span>(y)) tr[z].s[y == tr[z].s[<span class="hljs-number">1</span>]] = x;<br>    tr[x].p = z;<br>    tr[y].s[k] = tr[x].s[k ^ <span class="hljs-number">1</span>], tr[tr[x].s[k ^ <span class="hljs-number">1</span>]].p = y;<br>    tr[y].p = x, tr[x].s[k ^ <span class="hljs-number">1</span>] = y;<br>    <span class="hljs-built_in">pushup</span>(y), <span class="hljs-built_in">pushup</span>(x);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">splay</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//这里splay的时候，可能根到x路径上的懒标记没有传下来</span><br>    <span class="hljs-comment">//要先传懒标记</span><br>    <span class="hljs-type">int</span> top = <span class="hljs-number">0</span>, r = x;<br>    stk[++ top] = x;<br>    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">is_root</span>(r)) stk[++ top] = r = tr[r].p;<br>    <span class="hljs-keyword">while</span>(top) <span class="hljs-built_in">pushdown</span>(stk[top --]);<br>    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">is_root</span>(x))&#123;<br>        <span class="hljs-type">int</span> y = tr[x].p, z = tr[y].p;<br>        <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">is_root</span>(y))<br>            <span class="hljs-keyword">if</span>((x == tr[y].s[<span class="hljs-number">1</span>]) ^ (y == tr[z].s[<span class="hljs-number">1</span>])) <span class="hljs-built_in">rotate</span>(x);<br>            <span class="hljs-keyword">else</span> <span class="hljs-built_in">rotate</span>(y);<br>        <span class="hljs-built_in">rotate</span>(x);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//LCT函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">access</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span><span class="hljs-comment">//建立一条x到根的实边路径， 同时把x旋转到splay的根节点</span></span><br><span class="hljs-function"></span>&#123;   <br>    <span class="hljs-type">int</span> z = x;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> y = <span class="hljs-number">0</span>; x; y = x, x = tr[x].p)&#123;<br>        <span class="hljs-built_in">splay</span>(x);<br>        tr[x].s[<span class="hljs-number">1</span>] = y, <span class="hljs-built_in">pushup</span>(x);<br>    &#125;<br>    <span class="hljs-built_in">splay</span>(z);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">make_root</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span><span class="hljs-comment">//将x变为整棵树的根节点, 同时把x旋转到splay的根节点</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">access</span>(x);<br>    <span class="hljs-built_in">pushrev</span>(x);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find_root</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span><span class="hljs-comment">//找到x所在树的根节点，并把根节点旋转到spaly的根节点</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">access</span>(x);<br>    <span class="hljs-keyword">while</span>(tr[x].s[<span class="hljs-number">0</span>]) <span class="hljs-built_in">pushdown</span>(x), x = tr[x].s[<span class="hljs-number">0</span>];<br>    <span class="hljs-built_in">splay</span>(x);<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">split</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span><span class="hljs-comment">//建立x到y的实边路径，并且y是splay的根节点</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">make_root</span>(x);<br>    <span class="hljs-built_in">access</span>(y);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">link</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span><span class="hljs-comment">//如果x,y之间没有边，就加一条x到y的虚边</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">make_root</span>(x);<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">find_root</span>(y) != x) tr[x].p = y;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">cut</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span><span class="hljs-comment">//切掉x,y之间的边</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">make_root</span>(x);<br>    <span class="hljs-built_in">access</span>(y);<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">find_root</span>(y) == x &amp;&amp; tr[x].s[<span class="hljs-number">1</span>] == y &amp;&amp; !tr[y].s[<span class="hljs-number">0</span>])<br>        tr[x].s[<span class="hljs-number">1</span>] = tr[y].p = <span class="hljs-number">0</span>, <span class="hljs-built_in">pushup</span>(x);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;   <br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>        cin &gt;&gt; tr[i].v;<br><br>    <span class="hljs-keyword">while</span>(m --)&#123;<br>        <span class="hljs-type">int</span> op, x, y;<br>        cin &gt;&gt; op &gt;&gt; x &gt;&gt; y;<br>        <span class="hljs-keyword">if</span>(op == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">split</span>(x, y);<br>            cout &lt;&lt; tr[y].sum &lt;&lt; endl;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op == <span class="hljs-number">1</span>) <span class="hljs-built_in">link</span>(x, y);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op == <span class="hljs-number">2</span>) <span class="hljs-built_in">cut</span>(x, y);<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">splay</span>(x);<br>            tr[x].v = y;<br>            <span class="hljs-built_in">pushup</span>(x);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="点分治"><a href="#点分治" class="headerlink" title="点分治"></a>点分治</h2><ul><li>思想<ul><li>按照树的重心进行划分，对重心连接的每个子树进行处理</li><li>性质：按照重心划分出来的子树大小不会超过总点数的一半</li></ul></li><li>时间复杂度<ul><li>一共$logn$层，总复杂度为$logn$ * 每一层的复杂度</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">AcWing 252.树</span><br><span class="hljs-comment">给定一个有 N 个点（编号 0,1,…,N−1）的树，每条边都有一个权值（不超过 1000）。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">树上两个节点 x 与 y 之间的路径长度就是路径上各条边的权值之和。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">求长度不超过 K 的路径有多少条。</span><br><span class="hljs-comment">数据范围</span><br><span class="hljs-comment">1≤N≤10^4,</span><br><span class="hljs-comment">1≤K≤5×10^6,</span><br><span class="hljs-comment">0≤l≤10^3</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">10010</span>, M = N &lt;&lt; <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> h[N], e[M], w[M], ne[M], idx;<br><span class="hljs-type">bool</span> st[N];<br><span class="hljs-type">int</span> n, k;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;<br>e[idx] = a, w[idx] = c, ne[idx] = h[b], h[b] = idx ++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_size</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> fa)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(st[u]) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> sum = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[u]; ~i; i = ne[i])&#123;<br><span class="hljs-type">int</span> ver = e[i];<br><span class="hljs-keyword">if</span>(ver == fa) <span class="hljs-keyword">continue</span>;<br>sum += <span class="hljs-built_in">get_size</span>(ver, u);<br>&#125;<br><span class="hljs-keyword">return</span> sum;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_wc</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> fa, <span class="hljs-type">int</span> tot, <span class="hljs-type">int</span> &amp;wc)</span><span class="hljs-comment">//找到u为根的子树的重心</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(st[u]) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> sum = <span class="hljs-number">1</span>, mx = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[u]; ~i; i = ne[i])&#123;<br><span class="hljs-type">int</span> ver = e[i];<br><span class="hljs-keyword">if</span>(ver == fa) <span class="hljs-keyword">continue</span>;<br><span class="hljs-type">int</span> t = <span class="hljs-built_in">get_wc</span>(ver, u, tot, wc);<br>sum += t;<br>mx = <span class="hljs-built_in">max</span>(mx, t);<br>&#125;<br>mx = <span class="hljs-built_in">max</span>(mx, tot - sum);<br><span class="hljs-keyword">if</span>(mx &lt;= tot / <span class="hljs-number">2</span>) wc = u;<br><span class="hljs-keyword">return</span> sum;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_dist</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> fa, <span class="hljs-type">int</span> dist, vector&lt;<span class="hljs-type">int</span>&gt; &amp;vec)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(st[u]) <span class="hljs-keyword">return</span>;<br>vec.<span class="hljs-built_in">push_back</span>(dist);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[u]; ~i; i = ne[i])&#123;<br><span class="hljs-type">int</span> ver = e[i];<br><span class="hljs-keyword">if</span>(ver == fa) <span class="hljs-keyword">continue</span>;<br><span class="hljs-built_in">get_dist</span>(ver, u, dist + w[i], vec);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_ans</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;vec)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">sort</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>());<br><span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = vec.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, j = <span class="hljs-number">-1</span>; i &gt;= <span class="hljs-number">0</span>; i --)&#123;<br><span class="hljs-keyword">while</span>(j + <span class="hljs-number">1</span> &lt; i &amp;&amp; vec[j + <span class="hljs-number">1</span>] + vec[i] &lt;= k) j ++;<br>j = <span class="hljs-built_in">min</span>(j, i - <span class="hljs-number">1</span>);<br>res += j + <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span><span class="hljs-comment">//计算以u为根的子树内符合条件的线段数量</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(st[u]) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-built_in">get_wc</span>(u, <span class="hljs-number">-1</span>, <span class="hljs-built_in">get_size</span>(u, <span class="hljs-number">-1</span>), u);<br>st[u] = <span class="hljs-literal">true</span>;<span class="hljs-comment">//u此时就是重心</span><br><br><span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>vector&lt;<span class="hljs-type">int</span>&gt; p;<span class="hljs-comment">//所有节点到重心的距离</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[u]; ~i; i = ne[i])&#123;<br><span class="hljs-type">int</span> ver = e[i];<br>vector&lt;<span class="hljs-type">int</span>&gt; q;<span class="hljs-comment">//当前子树到重心的距离</span><br><span class="hljs-built_in">get_dist</span>(ver, u, w[i], q);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> c : q)&#123;<br><span class="hljs-keyword">if</span>(c &lt;= k) res ++;<br>p.<span class="hljs-built_in">push_back</span>(c);<br>&#125;<br>res -= <span class="hljs-built_in">get_ans</span>(q);<br>&#125;<br>res += <span class="hljs-built_in">get_ans</span>(p);<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[u]; ~i; i = ne[i]) res += <span class="hljs-built_in">calc</span>(e[i]);<br><br><span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>idx = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(h));<br><span class="hljs-built_in">memset</span>(st, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(st));<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i ++)&#123;<br><span class="hljs-type">int</span> a, b, c;<br>cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br><span class="hljs-built_in">add</span>(a, b, c);<br>&#125;<br><br>cout &lt;&lt; <span class="hljs-built_in">calc</span>(<span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><br><span class="hljs-keyword">while</span>(cin &gt;&gt; n &gt;&gt; k, n || k) <span class="hljs-built_in">solve</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="CDQ分治"><a href="#CDQ分治" class="headerlink" title="CDQ分治"></a>CDQ分治</h2><ul><li><p>解决问题：解决三维偏序问题</p></li><li><p>思想</p><ul><li>按照三关键字排序，这样对于每一个数符合条件的一定在其前面</li><li>每一个递归例程是求解这一例程对应对应区间内所有元素满足要求的对应的元素数量</li><li>对于一个区间，一分为二，左右分别递归，各自区间得到求解，但对于右半区间，左边区间对其产生的贡献还未统计，此时归并求解</li><li>归并方法：左半区间第一关键字一定已满足要求，且两区间内元素都按第二关键字排序(递归的副作用)，双指针统计右半边区间内每个元素在左区间内第二关键字满足的最大元素位置，两指针都往右走不会回头，同时用树状数组记录左半区间第三关键字的情况，对于右半区间每个元素，左区间内元素都到相应位置时(意味着，第一、第二关键字都已满足)，在树状数组中查询第三关键字满足要求的元素数量即可</li></ul></li><li><p>时间复杂度：$O(n * log(n)^2)$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">给定 n 个元素（编号 1∼n），其中第 i 个元素具有 ai,bi,ci 三种属性。</span><br><span class="hljs-comment">设 f(i) 表示满足以下 4 个条件：</span><br><span class="hljs-comment">aj≤ai</span><br><span class="hljs-comment">bj≤bi</span><br><span class="hljs-comment">cj≤ci</span><br><span class="hljs-comment">j≠i</span><br><span class="hljs-comment">的 j 的数量。</span><br><span class="hljs-comment">对于 d∈[0,n)，求满足 f(i)=d 的 i 的数量。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">数据范围</span><br><span class="hljs-comment">1≤n≤10^5,</span><br><span class="hljs-comment">1≤ai,bi,ci≤k≤2×10^5</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>, M = N &lt;&lt; <span class="hljs-number">1</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">data</span>&#123;<br><span class="hljs-type">int</span> a, b, c, s, res;<br><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt; (<span class="hljs-type">const</span> data &amp;t) <span class="hljs-type">const</span><br>&#123;<br><span class="hljs-keyword">if</span>(a != t.a) <span class="hljs-keyword">return</span> a &lt; t.a;<br><span class="hljs-keyword">if</span>(b != t.b) <span class="hljs-keyword">return</span> b &lt; t.b;<br><span class="hljs-keyword">return</span> c &lt; t.c;<br>&#125;<br><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>== (<span class="hljs-type">const</span> data &amp;t) <span class="hljs-type">const</span><br>&#123;<br><span class="hljs-keyword">return</span> a == t.a &amp;&amp; b == t.b &amp;&amp; c == t.c;<br>&#125;<br>&#125;q[N], tmp[N];<br><span class="hljs-type">int</span> tr[M], ans[N];<br><span class="hljs-type">int</span> n, m;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> x &amp; -x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = x; i &lt;= m; i += <span class="hljs-built_in">lowbit</span>(i)) tr[i] += c;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = x; i; i -= <span class="hljs-built_in">lowbit</span>(i)) res += tr[i];<br><span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(l &gt;= r) <span class="hljs-keyword">return</span>;<br><span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br><span class="hljs-built_in">merge_sort</span>(l, mid), <span class="hljs-built_in">merge_sort</span>(mid + <span class="hljs-number">1</span>, r);<br><br><span class="hljs-type">int</span> i = l, j = mid + <span class="hljs-number">1</span>, k = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r)<br><span class="hljs-keyword">if</span>(q[i].b &lt;= q[j].b) <span class="hljs-built_in">add</span>(q[i].c, q[i].s), tmp[k ++] = q[i ++];<br><span class="hljs-keyword">else</span> q[j].res += <span class="hljs-built_in">sum</span>(q[j].c), tmp[k ++] = q[j ++];<br><span class="hljs-keyword">while</span>(i &lt;= mid) <span class="hljs-built_in">add</span>(q[i].c, q[i].s), tmp[k ++] = q[i ++];<br><span class="hljs-keyword">while</span>(j &lt;= r) q[j].res += <span class="hljs-built_in">sum</span>(q[j].c), tmp[k ++] = q[j ++];<br><br><span class="hljs-comment">//清空树状数组</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = l; i &lt;= mid; i ++) <span class="hljs-built_in">add</span>(q[i].c, -q[i].s);<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = l, j = <span class="hljs-number">1</span>; i &lt;= r;) q[i ++] = tmp[j ++];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><br>cin &gt;&gt; n &gt;&gt; m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)&#123;<br><span class="hljs-type">int</span> a, b, c;<br>cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br>q[i] = &#123;a, b, c, <span class="hljs-number">1</span>&#125;;<br>&#125;<br><span class="hljs-built_in">sort</span>(q + <span class="hljs-number">1</span>, q + <span class="hljs-number">1</span> + n);<br><br><span class="hljs-comment">//去重、统计数量</span><br><span class="hljs-type">int</span> k = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i ++)<br><span class="hljs-keyword">if</span>(q[i] == q[k - <span class="hljs-number">1</span>]) q[k - <span class="hljs-number">1</span>].s ++;<br><span class="hljs-keyword">else</span> q[k ++] = q[i];<br><br><span class="hljs-built_in">merge_sort</span>(<span class="hljs-number">1</span>, k - <span class="hljs-number">1</span>);<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; k; i ++)<br>ans[q[i].res += q[i].s - <span class="hljs-number">1</span>] += q[i].s;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>cout &lt;&lt; ans[i] &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="AC自动机"><a href="#AC自动机" class="headerlink" title="AC自动机"></a>AC自动机</h2><p>用于解决多模式匹配问题，例如 很多个单词在一篇文章中出现了多少个</p><p>时间复杂度$O(n)$, n为文章长度</p><p>ne[]存储每个节点最大后缀相匹配的最大前缀</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs c++">acwing <span class="hljs-number">1282</span>题<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">10010</span>, M = <span class="hljs-number">1000010</span>, S = <span class="hljs-number">51</span>;<br><span class="hljs-type">int</span> tr[N * S][<span class="hljs-number">26</span>], cnt[N * S], idx;<br><span class="hljs-type">int</span> q[N * S], ne[M];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">char</span> str[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; str[i]; i ++)&#123;<br>        <span class="hljs-type">int</span> t = str[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>        <span class="hljs-keyword">if</span>(!tr[p][t]) tr[p][t] = ++ idx;<br>        p = tr[p][t];<br>    &#125;<br>    cnt[p] ++;<br>&#125;<br><span class="hljs-comment">//按照层来算， 已知i - 1层信息，算第i层信息，bfs</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i ++)<br>        <span class="hljs-keyword">if</span>(tr[<span class="hljs-number">0</span>][i])<br>            q[++ tt] = tr[<span class="hljs-number">0</span>][i];<br>    <br>    <span class="hljs-keyword">while</span>(hh &lt;= tt)&#123;<br>        <span class="hljs-type">int</span> t = q[hh ++];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i ++)&#123;<br>            <span class="hljs-comment">//int c = tr[t][i];</span><br>            <span class="hljs-comment">//if(!c) continue;</span><br>            <span class="hljs-comment">//int j = ne[t];</span><br>            <span class="hljs-comment">//while(j &amp;&amp; !tr[j][i]) j = ne[j];//找到有孩子i的节点</span><br>            <span class="hljs-comment">//if(tr[j][i]) j = tr[j][i];</span><br>            <span class="hljs-comment">//上面这一步可以优化，这段的核心是找到带有i的并且父节点是t的</span><br>            <span class="hljs-comment">//需要反复向上跳，优化的手段就是如果没有i这个孩子，就让它等于tr[ne[t]][i]</span><br>            <span class="hljs-comment">//这相当于记录了最终要跳的位置</span><br>            <span class="hljs-comment">//可优化成如下,这一步优化了，下面查找也要优化</span><br>            <span class="hljs-comment">// 可以理解为：本来要去找应该跳到哪，不存在才需要找，直接利用这空间存储应该跳到哪</span><br>            <span class="hljs-type">int</span> p = tr[t][i];<br>            <span class="hljs-keyword">if</span>(!p) tr[t][i] = tr[ne[t]][i];<br>            <span class="hljs-keyword">else</span>&#123;<br>                ne[p] = tr[ne[t]][i];<br>                q[++ tt] = p;<br>            &#125;<br>            <br>            <br>            ne[c] = j;<br>            q[++ tt] = c;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> T;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;T);<br>    <span class="hljs-keyword">while</span>(T --)&#123;<br>        <span class="hljs-built_in">memset</span>(tr, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> tr);<br>        <span class="hljs-built_in">memset</span>(cnt, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> cnt);<br>        <span class="hljs-built_in">memset</span>(q, <span class="hljs-number">0</span> ,<span class="hljs-keyword">sizeof</span> q);<br>        <br>        <span class="hljs-type">int</span> n;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>        <br>        <span class="hljs-type">char</span> str[M];<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)&#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, str);<br>            <span class="hljs-built_in">insert</span>(str);<br>        &#125;<br>        <br>        <span class="hljs-built_in">build</span>();<br>        <br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, str);<br>        <br>        <span class="hljs-comment">//匹配，j记录当前文本串中以str[i - 1]结尾的最大匹配</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; str[i]; i ++)&#123;<br>            <span class="hljs-type">int</span> t = str[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-comment">//while(j &amp;&amp; !tr[j][t]) j = ne[j];</span><br>            <span class="hljs-comment">//if(tr[j][t]) j = tr[j][t];</span><br>            <span class="hljs-comment">//建立优化以后，这里可以优化成</span><br>            j = tr[j][t];<br>            <br>            <span class="hljs-type">int</span> p = j;<br>            <span class="hljs-keyword">while</span>(p)&#123;<br>                res += cnt[p];<br>                cnt[p] = <span class="hljs-number">0</span>;<br>                p = ne[p];<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, res);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1</span><br><span class="hljs-comment">// ph[k]存储第k个插入的点在堆中的位置</span><br><span class="hljs-comment">// hp[k]存储堆中下标是k的点是第几个插入的</span><br><span class="hljs-type">int</span> h[N], ph[N], hp[N], size;<br><br><span class="hljs-comment">// 交换两个点，及其映射关系</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heap_swap</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">swap</span>(ph[hp[a]],ph[hp[b]]);<br>    <span class="hljs-built_in">swap</span>(hp[a], hp[b]);<br>    <span class="hljs-built_in">swap</span>(h[a], h[b]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">down</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> t = u;<br>    <span class="hljs-keyword">if</span> (u * <span class="hljs-number">2</span> &lt;= size &amp;&amp; h[u * <span class="hljs-number">2</span>] &lt; h[t]) t = u * <span class="hljs-number">2</span>;<span class="hljs-comment">//注意这里只能写成h[t],t一直记录的最小值</span><br>    <span class="hljs-keyword">if</span> (u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span> &lt;= size &amp;&amp; h[u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] &lt; h[t]) t = u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (u != t)<br>    &#123;<br>        <span class="hljs-built_in">heap_swap</span>(u, t);<br>        <span class="hljs-built_in">down</span>(t);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">up</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (u / <span class="hljs-number">2</span> &amp;&amp; h[u] &lt; h[u / <span class="hljs-number">2</span>])<br>    &#123;<br>        <span class="hljs-built_in">heap_swap</span>(u, u / <span class="hljs-number">2</span>);<br>        u &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// O(n)建堆</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n / <span class="hljs-number">2</span>; i; i -- ) <span class="hljs-built_in">down</span>(i);<br></code></pre></td></tr></table></figure><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>按存储结构分：拉链法， 开放寻址法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br>(<span class="hljs-number">1</span>) 拉链法<span class="hljs-comment">//h[N]表示哈希数组，其中每一个值都是一个小链表头</span><br>    <span class="hljs-comment">//e[N]用来存储所有的值</span><br>    <span class="hljs-type">int</span> h[N], e[N], ne[N], idx;<br><br>    <span class="hljs-comment">// 向哈希表中插入一个数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> k = (x % N + N) % N;<br>        e[idx] = x;<br>        ne[idx] = h[k];<br>        h[k] = idx ++ ;<br>    &#125;<br><br>    <span class="hljs-comment">// 在哈希表中查询某个数是否存在</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> k = (x % N + N) % N;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[k]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>            <span class="hljs-keyword">if</span> (e[i] == x)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>(<span class="hljs-number">2</span>) 开放寻址法<br>    <span class="hljs-type">int</span> h[N];<span class="hljs-comment">//通常开题目数据的两到三倍</span><br><span class="hljs-comment">//初始要对h数组中数字的标记</span><br><span class="hljs-built_in">memset</span>(h, <span class="hljs-number">0x3f</span>, <span class="hljs-built_in">sizeof</span>(h));<br><br>    <span class="hljs-comment">// 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> k = (x % N + N) % N;<br>        <span class="hljs-keyword">while</span> (h[k] != null &amp;&amp; h[k] != x)<span class="hljs-comment">//null为标记数字</span><br>        &#123;<br>            k ++ ;<br>            <span class="hljs-keyword">if</span> (k == N) k = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> k;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="字符串哈希"><a href="#字符串哈希" class="headerlink" title="字符串哈希"></a>字符串哈希</h2><p>思想：通过求每一段字符串的前缀数字表示，进而得出每一段字符串的数字表示</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++">核心思想：将字符串看成P进制数，P的经验值是<span class="hljs-number">131</span>或<span class="hljs-number">13331</span>，取这两个值的冲突概率低<br>小技巧：取模的数用<span class="hljs-number">2</span>^<span class="hljs-number">64</span>，这样直接用<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>存储，溢出的结果就是取模的结果<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ULL;<br>ULL h[N], p[N]; <span class="hljs-comment">// h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64</span><br><br><span class="hljs-comment">// 初始化</span><br>p[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>&#123;<br>    h[i] = h[i - <span class="hljs-number">1</span>] * P + str[i];<span class="hljs-comment">//str[i]转化成数字不能等于0</span><br>    p[i] = p[i - <span class="hljs-number">1</span>] * P;<br>&#125;<br><br><span class="hljs-comment">// 计算子串 str[l ~ r] 的哈希值</span><br><span class="hljs-function">ULL <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> h[r] - h[l - <span class="hljs-number">1</span>] * p[r - l + <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="字符串的最小表示"><a href="#字符串的最小表示" class="headerlink" title="字符串的最小表示"></a>字符串的最小表示</h2><p>对于一个长度为$n$字符串，把其看成一个环, 从任意一个字符开始的长度为$n$的所有字符串的，字典序最小的就是其最小表示</p><p>$O(n)$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">string <span class="hljs-title">getMin</span><span class="hljs-params">(string str)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n = str.<span class="hljs-built_in">size</span>();<br>    str = str + str;<br><br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(i &lt; n &amp;&amp; j &lt; n)&#123;<br>        <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(str[i + k] == str[j + k]) k ++;<br>        <span class="hljs-keyword">if</span>(k == n) <span class="hljs-keyword">break</span>;<span class="hljs-comment">//循环节，且以循环一轮</span><br>        <span class="hljs-keyword">if</span>(str[i + k] &gt; str[j + k]) i += k + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> j += k + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(i == j) j ++;<br>    &#125;<br>    <span class="hljs-type">int</span> k = <span class="hljs-built_in">min</span>(i, j);<br>    string res = str.<span class="hljs-built_in">substr</span>(k, n);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="三、搜索与图论"><a href="#三、搜索与图论" class="headerlink" title="三、搜索与图论"></a>三、搜索与图论</h1><h2 id="BFS与DFS"><a href="#BFS与DFS" class="headerlink" title="BFS与DFS"></a>BFS与DFS</h2><p><strong>BFS</strong></p><p>使用队列，while循环里对头元素四顾，出队，反复直至队列空</p><p>基于迭代，不会爆栈，每次搜索到的含有“最小”性质</p><ul><li><p>flood fill模型</p><p>找连通块，每次搜索把联通的全部标记，不会重复搜索 复杂度O(n)</p></li><li><p>最短路模型</p></li></ul><p>找最短步数类的题，每步花费一样，由于bfs的性质每次找到一个点都是到这个点的最短步数</p><p>一种最短步数模型是把每一种变化结果作为一个点， 如果一种状态A能变换成另一种状态B，B就可以由A扩展出来</p><ul><li>多源最短路</li></ul><p>求每一个特定点到多个终点中最短的最短距离，从所有终点开始bfs,每次扩展出来的点，就是终点这个点的最短距离（这里可以把所有终点想象成一个点）这里多个终点就变成了搜索的源点，即多源</p><ul><li>双端队列广搜</li></ul><p>应用于所有正权值相同，但含有0权值的最短路径，A搜到B，AB两个点间权值为0，说明AB属于同一层，应该把B加到队头，若AB间权值大于0，则B应该属于下一层，B加到队尾，这相当于不能把同一层的一次性搜完再搜下一层，（这里一层的点只会由上一层或同一层的点搜到，换句话说一个点只能搜到同层或下一层的点）同时，   搜索的过程中可能搜到同一层的也可能搜到下一层的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">AcWing 4481. 方格探索</span><br><span class="hljs-comment">给定一个 n 行 m 列的方格矩阵。行坐标从上到下为 1∼n，列坐标从左到右为 1∼m。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">其中的每个方格，要么是空格（用 . 表示），要么包含障碍物（用 * 表示）。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">初始时，一个人位于第 r 行第 c 列的空格之中。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">他可以沿上下左右四个方向进行移动，每次移动一格距离。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">对于他的移动，有如下限制：</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">他不能进入到包含障碍物的方格中，也不能走出矩阵的边界。</span><br><span class="hljs-comment">在整个移动过程中，他向左移动的总次数不能超过 x 次。</span><br><span class="hljs-comment">在整个移动过程中，他向右移动的总次数不能超过 y 次。</span><br><span class="hljs-comment">请问，一共有多少个空格是此人可以抵达的？</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">注意，初始空格视为此人可达。</span><br><span class="hljs-comment">n &lt;= 2000</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> PII = pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2010</span>;<br><span class="hljs-type">char</span> g[N][N];<br><span class="hljs-type">int</span> n, m, r, c, a, b;<br><span class="hljs-type">int</span> dist[N][N];<br><span class="hljs-type">bool</span> st[N][N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> r, <span class="hljs-type">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-built_in">sizeof</span>(dist));<br>    dist[r][c] = <span class="hljs-number">0</span>;<br>    deque&lt;PII&gt; dq;<br>    dq.<span class="hljs-built_in">push_back</span>(&#123;r, c&#125;);<br><br>    <span class="hljs-type">int</span> dx[] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;, dy[] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span> ,<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>&#125;;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(dq.<span class="hljs-built_in">size</span>())&#123;<br>        <span class="hljs-keyword">auto</span> t = dq.<span class="hljs-built_in">front</span>();<br>        dq.<span class="hljs-built_in">pop_front</span>();<br>        <span class="hljs-type">int</span> x = t.first, y = t.second;<br><br>        <span class="hljs-keyword">if</span>(st[x][y]) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(dist[x][y] &lt;= b &amp;&amp; dist[x][y] - (y - c) &lt;= a) res ++;<br>        &#125;<br><br>        st[x][y] = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i ++)&#123;<br>            <span class="hljs-type">int</span> nx = x + dx[i], ny = y + dy[i];<br><br>            <span class="hljs-keyword">if</span>(nx &lt; <span class="hljs-number">1</span> || nx &gt; n || ny &lt; <span class="hljs-number">1</span> || ny &gt; m || g[nx][ny] == <span class="hljs-string">&#x27;*&#x27;</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(i == <span class="hljs-number">3</span>)&#123;<br>                dist[nx][ny] = <span class="hljs-built_in">min</span>(dist[nx][ny], dist[x][y] + <span class="hljs-number">1</span>);<br>                dq.<span class="hljs-built_in">push_back</span>(&#123;nx, ny&#125;);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                dist[nx][ny] = <span class="hljs-built_in">min</span>(dist[nx][ny], dist[x][y]);<br>                dq.<span class="hljs-built_in">push_front</span>(&#123;nx, ny&#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; r &gt;&gt; c &gt;&gt; a &gt;&gt; b;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>        cin &gt;&gt; g[i] + <span class="hljs-number">1</span>;<br><br>    cout &lt;&lt; <span class="hljs-built_in">bfs</span>(r, c) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>双向广搜</p><p>搜索的中间状态可能过多，从起点直接往终点搜会爆复杂度，因此，从起点和终点同时搜，两个搜索同时搜到一个中间态即可得到答案，若搜索过程中有一个队列变空，说明无解。例题 acwing190字符变换</p><p>A*算法</p><p>用于从起点到终点状态过多的情况，无解时A*会很慢</p><p>为每一个状态添加估计函数，估计函数必须非负，估计当前状态到终点的距离，每次选择队列中当前距离加估计距离最小的状态进行扩展，（这里用优先队列，注意要定义成小根堆）</p><p>终点状态出队时一定是最优的，也就是最短距离 注意：估计函数值f()一定要小于等于当前状态到终止状态的实际最优值g()，第一次出队取到最小距离只对终点成立，每个点可能入队多次</p><p>证明（解存在时）：从起点开始扩展，扩展的状态里一定有最优路径上的状态，最优路径上的状态一定会再扩展出最优路径上的状态，即队列中每时每刻都存在最优路径上的状态u, 假设当终止状态出队时不是最优解，dist(终止)&gt; dist(最优)，则队列中一定存在最优路径上的状态u，</p><p>dsit(u) + f(u) &lt;&#x3D; dist(u) + g(u) &#x3D; dist(最优) &lt; dist(终止) 这与队列每次出队当前实际距离加估计距离的最小值矛盾，故终止状态出队时一定为最优</p><p><strong>DFS</strong></p><p>通常写成递归，用系统栈，若爆栈，则需要改成非递归，若有一递归分支是无条件的则必须return，</p><p>通常是满足答案则输出，否者递归搜索</p><p>dfs与连通性</p><p>dfs也可以找连通块，但只能知道是否联通，并不知道到每个点的最短距离；</p><p>dfs的搜索顺序</p><p>在保证能搜到最优解的同时做适当的优化（剪枝）</p><p>dfs剪枝</p><p>1、优化搜索顺序</p><p>大部分情况下，优先搜索分支较少的节点，此时会得到解，以后搜索分支较多的节点时，其更容易被最优性剪枝剪掉</p><p>2、排除等效冗余，列入有的应该按照组合数搜索，不应该按照排列数搜索，因为不考虑组内顺序，此时搜索时加入搜索顺序，可以排除大量等效冗余</p><p>3、可行性剪枝，当前搜索已经不满足题目要求，方案不可行，直接返回即可</p><p>4、最优性剪枝，当前搜索所能找到的解大于等于当前搜到的答案，即当前搜索不能更新最优解，直接返回即可</p><p>dfs迭代加深</p><p>问题的解在比较浅的层次，但可能会搜到很深的层次，因此，定义一个最大的搜索深度，若在此深度内未搜到解，则深度加深后从新搜索，可以这样做的原因是，搜索树最后一层的节点数量比前面所有层的节点数量加起来要多</p><p>双向dfs</p><p>空间换时间，先打表部分要搜索的，把所有可能的结果存在表中，只搜索另一部分，另一部分搜索完成后，再去表中查，与搜索的结果拼成答案，然后查看是否能更新最优解</p><p>IDA*</p><p>迭代加深+全局最优性剪枝，每次定义一个最大搜索深度，同时有一个估计函数，估计当前能否在目前的最大深度内搜到解，所估计的值大于当前最大深度直接返回</p><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p>没有回向边</p><p>核心思想：先找到入度为0的点，入队，把其去掉后，其所连接的点入读减减，减到0后表示其其前面的点已经完成，不必回向，入队，</p><p>因此入队顺序就是拓扑序列</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    queue&lt;<span class="hljs-type">int</span>&gt; Q;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>        <span class="hljs-keyword">if</span>(d[i] == <span class="hljs-number">0</span>) &#123;<br>            Q.<span class="hljs-built_in">push</span>(i);<span class="hljs-comment">//Q是遍历队列</span><br>            ans.<span class="hljs-built_in">push</span>(i);<span class="hljs-comment">//ans是答案队列</span><br>        &#125;<br>    <br>    <span class="hljs-keyword">while</span>(!Q.<span class="hljs-built_in">empty</span>())&#123;<br>        <span class="hljs-type">int</span> t = Q.<span class="hljs-built_in">front</span>(); Q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[t]; i != <span class="hljs-number">-1</span>; i = ne[i])&#123;<br>            <span class="hljs-type">int</span> j = e[i]; d[j] --;<br>            <span class="hljs-keyword">if</span>(d[j] == <span class="hljs-number">0</span>)&#123;<br>            Q.<span class="hljs-built_in">push</span>(j); ans.<span class="hljs-built_in">push</span>(j);<br>            &#125;    <br>        &#125;<br>    &#125;    <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h2><p>最短路可能还有乘法，对于所有乘数大于0的情况，若乘数都小于1，相当于正权图，若乘数有的大于1，有的小于1，则只能用spfa，相当于含有负权图</p><p>因为小于1时每确定一个点的最大值，后面的路径都不能使它变的更大</p><ul><li>朴素$dijkstra$ : 用于单源正权值最短路，稠密图，邻接矩阵存储、</li></ul><p>此算法关注点在点</p><p>时间复杂是 $O(n^2+m) $, $n$表示点数，$m$ 表示边数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> g[N][N];  <span class="hljs-comment">// 存储每条边</span><br><span class="hljs-type">int</span> dist[N];  <span class="hljs-comment">// 存储1号点到每个点的最短距离</span><br><span class="hljs-type">bool</span> flag[N];   <span class="hljs-comment">// 存储每个点的最短路是否已经确定</span><br><br><span class="hljs-comment">// 求1号点到n号点的最短路，如果不存在则返回-1</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>;     <span class="hljs-comment">// 在还未确定最短路的点中，寻找距离最小的点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++ )<br>            <span class="hljs-keyword">if</span> (!flag[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || dist[t] &gt; dist[j]))<br>                t = j;<br><br>        <span class="hljs-comment">// 用t更新其他点的距离</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++ )<br>            dist[j] = <span class="hljs-built_in">min</span>(dist[j], dist[t] + g[t&#125;[j]);<br><br>        flag[t] = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (dist[n] == <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>堆优化版$dijkstra$</li></ul><p>邻接表存储，稀疏图</p><p>时间复杂度 $O(mlogn)$ $n$ 表示点数，$m$ 表示边数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;<br><br><span class="hljs-type">int</span> n; <span class="hljs-comment">// 点的数量</span><br><span class="hljs-type">int</span> h[N], w[N], e[N], ne[N], idx;<span class="hljs-comment">// 邻接表存储所有边</span><br><span class="hljs-type">int</span> dist[N];<span class="hljs-comment">// 存储所有点到1号点的距离</span><br><span class="hljs-type">bool</span> flag[N];<span class="hljs-comment">// 存储每个点的最短距离是否已确定</span><br><br><span class="hljs-comment">// 求1号点到n号点的最短距离，如果不存在，则返回-1</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;<br>    heap.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;);<span class="hljs-comment">// first存储距离，second存储节点编号</span><br><span class="hljs-keyword">while</span> (heap.<span class="hljs-built_in">size</span>())<br>&#123;<br>    <span class="hljs-keyword">auto</span> t = heap.<span class="hljs-built_in">top</span>();<br>    heap.<span class="hljs-built_in">pop</span>();<br><br>    <span class="hljs-type">int</span> ver = t.second, distance = t.first;<br><br>    <span class="hljs-keyword">if</span> (flag[ver]) <span class="hljs-keyword">continue</span>;<br>    flag[ver] = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[ver]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>    &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span> (dist[j] &gt; distance + w[i])<br>        &#123;<br>            dist[j] = distance + w[i];<br>            heap.<span class="hljs-built_in">push</span>(&#123;dist[j], j&#125;);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">if</span> (dist[n] == <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">return</span> dist[n];<br>&#125;<br></code></pre></td></tr></table></figure><p>$dijkstra$的核心是：先找到距离始点最近的点（初始为始点本身），然后用此点更新与其相连的点的距离。</p><ul><li>$bellmanFord$ : 适用于有负权边,此算法关注点在边，可以求有边的限制的最短路</li></ul><p>每次更新点可能会有连锁反应，一次更新了好多点，这与边的顺序有关，可能会提前得到所有点的最短路，但依赖边的顺序，因此保证解的正确要更新$n$次，因此最坏$n$全部正确更新</p><p>时间复杂度$O(n*m)$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++">nt n, m;       <span class="hljs-comment">// n表示点数，m表示边数</span><br><span class="hljs-type">int</span> dist[N];        <span class="hljs-comment">// dist[x]存储1到x的最短路距离</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>     <span class="hljs-comment">// 边，a表示出点，b表示入点，w表示边的权重</span><br>&#123;<br>    <span class="hljs-type">int</span> a, b, w;<br>&#125;edges[M];<br><br><span class="hljs-comment">// 求1到n的最短路距离，如果无法从1走到n，则返回-1。</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bellman_ford</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j ++ )<br>        &#123;<br>            <span class="hljs-type">int</span> a = edges[j].a, b = edges[j].b, w = edges[j].w;<br>            <span class="hljs-keyword">if</span> (dist[b] &gt; dist[a] + w)<br>                dist[b] = dist[a] + w;<br>        &#125;<br>    &#125;<br><span class="hljs-comment">//因为无脑更新所有边，所以，就算到不了也可能让其dist比0x3f3f3f3f小，而spfa更新所有已经更新的点的边，所以，到不了的点不会被更新</span><br>    <span class="hljs-keyword">if</span> (dist[n] &gt; <span class="hljs-number">0x3f3f3f3f</span> / <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>spfa 算法（队列优化的$BellmanFord$算法）</li></ul><p>优化原理是只有当前点距离变小才会更新与其相连的点，因此，把所有距离变小的点入队</p><p>时间复杂度 平均情况下 $O(m)$，最坏情况下 $O(n*m)$, $n$ 表示点数，$m$ 表示边数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> n;      <span class="hljs-comment">// 总点数</span><br><span class="hljs-type">int</span> h[N], w[N], e[N], ne[N], idx;       <span class="hljs-comment">// 邻接表存储所有边</span><br><span class="hljs-type">int</span> dist[N];        <span class="hljs-comment">// 存储每个点到1号点的最短距离</span><br><span class="hljs-type">bool</span> st[N];     <span class="hljs-comment">// 存储每个点是否在队列中</span><br><br><span class="hljs-comment">// 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>    st[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>())<br>    &#123;<br>        <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br><br>        st[t] = <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>        &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (dist[j] &gt; dist[t] + w[i])<br>            &#123;<br>                dist[j] = dist[t] + w[i];<br>                <span class="hljs-keyword">if</span> (!st[j])     <span class="hljs-comment">// 如果队列中已存在j，则不需要将j重复插入</span><br>                &#123;<br>                    q.<span class="hljs-built_in">push</span>(j);<br>                    st[j] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (dist[n] == <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>spfa找负环</li></ul><p>时间复杂度是 $O(n*m)$, $n$ 表示点数，$m$ 表示边数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> n;      <span class="hljs-comment">// 总点数</span><br><span class="hljs-type">int</span> h[N], w[N], e[N], ne[N], idx;       <span class="hljs-comment">// 邻接表存储所有边</span><br><span class="hljs-type">int</span> dist[N], cnt[N];        <span class="hljs-comment">// dist[x]存储1号点到x的最短距离，cnt[x]存储1到x的最短路中经过的点数</span><br><span class="hljs-type">bool</span> st[N];     <span class="hljs-comment">// 存储每个点是否在队列中</span><br><br><span class="hljs-comment">// 如果存在负环，则返回true，否则返回false。</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 不需要初始化dist数组，因为如果存在负环，其到始点的距离一定会变负</span><br>    <span class="hljs-comment">// 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环。</span><br>    <span class="hljs-comment">//所有点入队，是因为从某些点可能走不到负环，因此cnt表示的是每个联通域，其他各点到联通域起点走过的边数</span><br>    <span class="hljs-comment">//负环上的点会反复入队</span><br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>    &#123;<br>        q.<span class="hljs-built_in">push</span>(i);<br>        st[i] = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>())<br>    &#123;<br>        <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br><br>        st[t] = <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>        &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (dist[j] &gt; dist[t] + w[i])<br>            &#123;<br>                dist[j] = dist[t] + w[i];<br>                cnt[j] = cnt[t] + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (cnt[j] &gt;= n) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;       <span class="hljs-comment">// 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环（因为共只有n个点）</span><br>                <span class="hljs-keyword">if</span> (!st[j])<br>                &#123;<br>                    q.<span class="hljs-built_in">push</span>(j);<br>                    st[j] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>floyd算法：用于求多源汇最短路问题，思想是基于动态规划</li></ul><p>任意两个点的之间的所有通路都会被遍历到，任取任意两点s,e之间的一条通路，通路上的点都会作为中间点，以更新其他两点之间距离，最终会更新到s，e两点之间的距离</p><p>时间复杂度是 $O(n^3)$, n 表示点数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++">初始化：<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++ )<br>            <span class="hljs-keyword">if</span> (i == j) d[i][j] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span> d[i][j] = INF;<br><br><span class="hljs-comment">// 算法结束后，d[a][b]表示a到b的最短距离</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">floyd</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= n; k ++ )<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++ )<br>                d[i][j] = <span class="hljs-built_in">min</span>(d[i][j], d[i][k] + d[k][j]);<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>floyd算法应用，求传递闭包，最小环，恰好经过k条边的最短距离（对floyd进行变形）</li></ul><hr><h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><ul><li>朴素版prim算法</li></ul><p>稠密图，邻接矩阵</p><p> Prim算法求最小生成树<br>时间复杂度是 $O(n^2+m)$, n 表示点数，m 表示边数</p><p>思想：每次找到当前距离连通域最小的点，再用这个点去更新其他点到连通域的距离</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> n;      <span class="hljs-comment">// n表示点数</span><br><span class="hljs-type">int</span> g[N][N];        <span class="hljs-comment">// 邻接矩阵，存储所有边</span><br><span class="hljs-type">int</span> dist[N];        <span class="hljs-comment">// 存储其他点到当前最小生成树的距离</span><br><span class="hljs-type">bool</span> flag[N];     <span class="hljs-comment">// 存储每个点是否已经在生成树中</span><br><br><br><span class="hljs-comment">// 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">prim</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br><br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//循环n次是因为从第一个点开始加入集合</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++ )<br>            <span class="hljs-keyword">if</span> (!flag[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || dist[t] &gt; dist[j]))<br>                t = j;<br><span class="hljs-comment">//如果当前不是第一个点，且到联通域距离为无穷大，则其不联通</span><br>        <span class="hljs-keyword">if</span> (i &amp;&amp; dist[t] == INF) <span class="hljs-keyword">return</span> INF;<br><span class="hljs-comment">//不是第一个点，则更新边权和，要写在用t更新其他点到连通域距离的前面,因为t若有负自环，会把自己到连通域的距离再次更新，最小生成树不考虑自环</span><br>   <br>        <span class="hljs-keyword">if</span> (i) res += dist[t];<br>        flag[t] = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++ ) dist[j] = <span class="hljs-built_in">min</span>(dist[j], g[t][j]);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>$Kruskal$算法</li></ul><p>稀疏图</p><p>时间复杂度是 $O(mlogm)$, $n$ 表示点数，$m$ 表示边数</p><p>思想：先把所有边从小到大排序，然后依次枚举每条边，若该边连接的两点不连通（并查集），就把该边加入到最小生成树中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> n, m;       <span class="hljs-comment">// n是点数，m是边数</span><br><span class="hljs-type">int</span> p[N];       <span class="hljs-comment">// 并查集的父节点数组</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>     <span class="hljs-comment">// 存储边</span><br>&#123;<br>    <span class="hljs-type">int</span> a, b, w;<br><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt; (<span class="hljs-type">const</span> Edge &amp;W)<span class="hljs-type">const</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> w &lt; W.w;<br>    &#125;<br>&#125;edges[M];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>     <span class="hljs-comment">// 并查集核心操作</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (p[x] != x) p[x] = <span class="hljs-built_in">find</span>(p[x]);<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kruskal</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">sort</span>(edges, edges + m);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) p[i] = i;    <span class="hljs-comment">// 初始化并查集</span><br><br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>, cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> a = edges[i].a, b = edges[i].b, w = edges[i].w;<br><br>        a = <span class="hljs-built_in">find</span>(a), b = <span class="hljs-built_in">find</span>(b);<br>        <span class="hljs-keyword">if</span> (a != b)     <span class="hljs-comment">// 如果两个连通块不连通，则将这两个连通块合并</span><br>        &#123;<br>            p[a] = b;<br>            res += w;<br>            cnt ++ ;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (cnt &lt; n - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> INF;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br></code></pre></td></tr></table></figure><hr><h2 id="差分约束"><a href="#差分约束" class="headerlink" title="差分约束"></a>差分约束</h2><p>对与一系列形如$x_i \leq x_j + c$的不等式，求每个变量的最小值或最大值</p><ul><li>最小值<ul><li>使用最长路</li><li>把每个不等式转化为上述形式，由$j$向$i$连一条长度为$c$的边</li><li>负环判定有无解</li></ul></li><li>最大值<ul><li>使用最短路</li><li>把每个不等式转化为上述形式，由$i$向$j$连一条长度为$-c$的边</li><li>正环判定有无解</li></ul></li><li>$spfa$正负环判定<ul><li>判定每个点的被更新次数是否大于等于总点数即可，大于即存在正负环</li><li>优化技巧：可尝试把队列改为栈</li><li>若没有一个点存在一个路径到达其余所有点，可无脑初始直接把所有点入队\栈</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">幼儿园里有 N 个小朋友，老师现在想要给这些小朋友们分配糖果，要求每个小朋友都要分到糖果。</span><br><span class="hljs-comment">如果 X=1．表示第 A 个小朋友分到的糖果必须和第 B 个小朋友分到的糖果一样多。</span><br><span class="hljs-comment">如果 X=2，表示第 A 个小朋友分到的糖果必须少于第 B 个小朋友分到的糖果。</span><br><span class="hljs-comment">如果 X=3，表示第 A 个小朋友分到的糖果必须不少于第 B 个小朋友分到的糖果。</span><br><span class="hljs-comment">如果 X=4，表示第 A 个小朋友分到的糖果必须多于第 B 个小朋友分到的糖果。</span><br><span class="hljs-comment">如果 X=5，表示第 A 个小朋友分到的糖果必须不多于第 B 个小朋友分到的糖果。</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> LL = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100007</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> M = <span class="hljs-number">300007</span>;<br><span class="hljs-type">int</span> h[N], e[M], w[M], ne[M], idx;<br><span class="hljs-type">int</span> q[N], cnt[N];<br>LL d[N];<br><span class="hljs-type">bool</span> st[N];<br><span class="hljs-type">int</span> n, m;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v, <span class="hljs-type">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = v, w[idx] = c, ne[idx] = h[u], h[u] = idx ++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(d, <span class="hljs-number">-0x3f</span>, <span class="hljs-built_in">sizeof</span>(d));<br>    d[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> tt = <span class="hljs-number">1</span>;<br>    q[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span>(tt)&#123;<br>        <span class="hljs-type">int</span> t = q[tt --];<br>        st[t] = <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[t]; ~i; i = ne[i])&#123;<br>            <span class="hljs-type">int</span> ver = e[i];<br>            <span class="hljs-keyword">if</span>(d[ver] &lt; d[t] + w[i])&#123;<br>                d[ver] = d[t] + w[i];<br>                cnt[ver] = cnt[t] + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span>(cnt[ver] &gt;= n + <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">if</span>(!st[ver])&#123;<br>                    q[++ tt] = ver;<br>                    st[ver] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sovle</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;   <br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(h));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i ++)&#123;<br>        <span class="hljs-type">int</span> t, a, b;<br>        cin &gt;&gt; t &gt;&gt; a &gt;&gt; b;<br>        <span class="hljs-keyword">if</span>(t == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-built_in">add</span>(a, b, <span class="hljs-number">0</span>), <span class="hljs-built_in">add</span>(b, a, <span class="hljs-number">0</span>);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t == <span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-built_in">add</span>(a, b, <span class="hljs-number">1</span>);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t == <span class="hljs-number">3</span>)&#123;<br>            <span class="hljs-built_in">add</span>(b, a, <span class="hljs-number">0</span>);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t == <span class="hljs-number">4</span>)&#123;<br>            <span class="hljs-built_in">add</span>(b, a, <span class="hljs-number">1</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">add</span>(a, b, <span class="hljs-number">0</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>        <span class="hljs-built_in">add</span>(<span class="hljs-number">0</span>, i, <span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">spfa</span>())&#123;<br>        LL res = <span class="hljs-built_in">accumulate</span>(d + <span class="hljs-number">1</span>, d + <span class="hljs-number">1</span> + n, <span class="hljs-number">0ll</span>);<br>        cout &lt;&lt; res &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>    cout &lt;&lt; <span class="hljs-built_in">setiosflags</span>(ios::fixed) &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">2</span>);<br>    <span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//cin &gt;&gt; T;</span><br>    <span class="hljs-keyword">while</span>(T --)&#123;<br>        <span class="hljs-built_in">sovle</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="最近公共祖先（-lca-）"><a href="#最近公共祖先（-lca-）" class="headerlink" title="最近公共祖先（$lca$）"></a>最近公共祖先（$lca$）</h2><ul><li>倍增求$lca$模板</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//设置哨兵0号点，fa[0][j] = 0, depth[0] = 0, 因此根节点depth为1</span><br><span class="hljs-type">int</span> depth[N];<br><span class="hljs-type">int</span> fa[N][k];<span class="hljs-comment">//k的范围依据数据范围而定，2^k &lt; N, 离N最进的k</span><br><span class="hljs-comment">//预处理fa[i][j]表示从i跳2^j步跳到哪里</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(depth, <span class="hljs-number">0x3f</span>, <span class="hljs-built_in">sizeof</span>(depth));<br>    depth[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>, depth[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">0</span>;<br>    q[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">while</span>(hh &lt;= tt)&#123;<br>        <span class="hljs-type">int</span> t = q[hh ++];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[t]; ~i; i = ne[i])&#123;<br>            <span class="hljs-type">int</span> ver = e[i];<br>            <span class="hljs-keyword">if</span>(depth[ver] &gt; depth[t] + <span class="hljs-number">1</span>)&#123;<br>                depth[ver] = depth[t] + <span class="hljs-number">1</span>;<br>                fa[ver][<span class="hljs-number">0</span>] = t;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= <span class="hljs-number">16</span>; k ++)<br>                    fa[ver][k] = fa[fa[ver][k - <span class="hljs-number">1</span>]][k - <span class="hljs-number">1</span>];<br>                q[++ tt] = ver;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(depth[u] &lt; depth[v]) <span class="hljs-built_in">swap</span>(u, v);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">16</span>; k &gt;= <span class="hljs-number">0</span>; k --)<br>        <span class="hljs-keyword">if</span>(depth[fa[u][k]] &gt;= depth[v])<br>            u = fa[u][k];<br>    <span class="hljs-keyword">if</span>(u == v) <span class="hljs-keyword">return</span> u;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">16</span>; k &gt;= <span class="hljs-number">0</span>; k --)<br>        <span class="hljs-keyword">if</span>(fa[u][k] != fa[v][k])&#123;<br>            u = fa[u][k];<br>            v = fa[v][k];<br>        &#125;<br>    <span class="hljs-keyword">return</span> fa[u][<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>$tarjan$求$lca$</li></ul><p>关于tarjan求lca的理解</p><p>对于每个节点$u$，我们求关于u的询问是在回溯到$u$的时候，设此时与$u$相关的询问节点是$v$，且$v$被标记成了$2$，即$v$已经被遍历完，因为$u \neq v$, 则$u$和$v$一定位于其最近公共祖先$lca$的两个分支，且$v$被标记成了$2$，而此时在遍历$u$说明从最近公共祖先出发，$v$所在的链已经被遍历完，$v$所在链上的节点，其并查集的代表元素都是$lca$，这一点可以证明，若标记成$lca$的祖先，因为此时遍历到$u$，但$lca$的所有子孙节点还没有遍历完，因此，不可能标记成$lca$的祖先。若标记成，$lca$的子孙节点$lcason$的话，则从$v$和$u$就是$lcason$的两个分支，这与$lca$是最近公共祖先矛盾，因此，$v$的表标记的一定是$lca$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;<br><span class="hljs-type">int</span> h[N], e[M], w[M], ne[M], idx;<br>vector&lt;PII&gt; query[N];   <span class="hljs-comment">// first存查询的另外一个点，second存查询编号</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">tarjan</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    st[u] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[u]; ~i; i = ne[i])<br>    &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span> (!st[j])<br>        &#123;<br>            <span class="hljs-built_in">tarjan</span>(j);<br>            p[j] = u;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> item : query[u])<br>    &#123;<br>        <span class="hljs-type">int</span> y = item.first, id = item.second;<br>        <span class="hljs-keyword">if</span> (st[y] == <span class="hljs-number">2</span>)<br>        &#123;<br>            <span class="hljs-type">int</span> anc = <span class="hljs-built_in">find</span>(y);<br>            res[id] = dist[u] + dist[y] - dist[anc] * <span class="hljs-number">2</span>;<span class="hljs-comment">//求出公共祖先要做的操作</span><br>        &#125;<br>    &#125;<br><br>    st[u] = <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="有向图的强连通分量"><a href="#有向图的强连通分量" class="headerlink" title="有向图的强连通分量"></a>有向图的强连通分量</h2><ul><li><p>联通分量：对于分量中的任意两点$u,v$, $u, v$可以互相走到</p></li><li><p>强联通分量：极大联通分量</p></li><li><p>求完$scc$后缩点，能把原图变为有向无环图$（DAG）$,强连通分量的倒序就是缩完点后图的拓扑排序</p></li><li><p>模板</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//核心思想:每一个节点为根的子树，若dfn[u] == low[u]搜完其所有节点，此时栈中到u的点就是u所在的scc</span><br><span class="hljs-type">int</span> dfn[N], low[N], timestamp;<br><span class="hljs-type">int</span> stk[N], top;<br><span class="hljs-type">int</span> id[N], sz[N], sccCnt;<br><span class="hljs-type">bool</span> inStk[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">tarjan</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    dfn[u] = low[u] = ++ timestamp;<br>    stk[++ top] = u, inStk[u] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[u]; ~i; i = ne[i])&#123;<br>        <span class="hljs-type">int</span> ver = e[i];<br>        <span class="hljs-keyword">if</span>(!dfn[ver])&#123;<br>            <span class="hljs-built_in">tarjan</span>(ver);<br>            low[u] = <span class="hljs-built_in">min</span>(low[u], low[ver]);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(inStk[ver]) low[u] = <span class="hljs-built_in">min</span>(low[u], dfn[ver]);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(dfn[u] == low[u])&#123;<br>        sccCnt ++;<br>        <span class="hljs-type">int</span> ver;<br>        <span class="hljs-keyword">do</span>&#123;<br>            ver = stk[top --];<br>            inStk[ver] = <span class="hljs-literal">false</span>;<br>            id[ver] = sccCnt;<br>            sz[sccCnt] ++;<br>        &#125;<span class="hljs-keyword">while</span>(ver != u);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="无向图的双连通分量"><a href="#无向图的双连通分量" class="headerlink" title="无向图的双连通分量"></a>无向图的双连通分量</h2><ul><li>边连通分量($edcc$)<ul><li>桥：对于一条边，如果把这条边去掉，图不连通，则这条边称为桥</li><li>最大的不含桥的联通分量称为边联通分量</li></ul></li></ul><p>$tarjan$算法求$edcc$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//注意按照边搜索，所按照点来搜索（不回搜父亲即可）会被重边卡掉</span><br><span class="hljs-comment">//dfn[u] &lt; low[j] 说明从u到j的这条边是桥边</span><br><span class="hljs-comment">//dfn[u] == low[u] 说明以u为根的子树是一个边连通分量</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">对于一个无向图，至少加多少条边使其变成边联通分量</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> N = <span class="hljs-number">5007</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> M = <span class="hljs-number">10007</span>;<br><span class="hljs-type">int</span> h[N], e[M], ne[M], idx;<br><span class="hljs-type">int</span> dfn[N], low[N], timestamp;<br><span class="hljs-type">int</span> stk[N], top;<br><span class="hljs-type">int</span> id[N], edccCnt;<br><span class="hljs-type">bool</span> isBridge[N];<br><span class="hljs-type">int</span> deg[N];<br><span class="hljs-type">int</span> n, m;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = v, ne[idx] = h[u], h[u] = idx ++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">tarjan</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> from)</span></span><br><span class="hljs-function"></span>&#123;<br>    dfn[u] = low[u] = ++ timestamp;<br>    stk[++ top] = u;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[u]; ~i; i = ne[i])&#123;<br>        <span class="hljs-type">int</span> ver = e[i];<br>        <span class="hljs-keyword">if</span>(!dfn[ver])&#123;<br>            <span class="hljs-built_in">tarjan</span>(ver, i);<br>            low[u] = <span class="hljs-built_in">min</span>(low[u], low[ver]);<br>            <span class="hljs-keyword">if</span>(dfn[u] &lt; low[ver])&#123;<br>                isBridge[i] = isBridge[i ^ <span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i != (from ^ <span class="hljs-number">1</span>)) low[u] = <span class="hljs-built_in">min</span>(low[u], dfn[ver]);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(dfn[u] == low[u])&#123;<br>        ++ edccCnt;<br>        <span class="hljs-type">int</span> ver;<br>        <span class="hljs-keyword">do</span>&#123;<br>            ver = stk[top --];<br>            id[ver] = edccCnt;<br>        &#125;<span class="hljs-keyword">while</span>(ver != u);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sovle</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;   <br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(h));<br>    <span class="hljs-keyword">while</span>(m --)&#123;<br>        <span class="hljs-type">int</span> u, v;<br>        cin &gt;&gt; u &gt;&gt; v;<br>        <span class="hljs-built_in">add</span>(u, v), <span class="hljs-built_in">add</span>(v, u);<br>    &#125;<br><br>    <span class="hljs-built_in">tarjan</span>(<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; idx; i ++)<br>        <span class="hljs-keyword">if</span>(isBridge[i]) deg[id[e[i]]] ++;<br><br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= edccCnt; i ++)<br>        <span class="hljs-keyword">if</span>(deg[i] == <span class="hljs-number">1</span>) cnt ++;<br>    cout &lt;&lt; (cnt + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>点连通分量($vdcc$)</li></ul><p>$tarjan$求$vdcc$模板</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//割点属于多个点连通分量，每个点连通分量都包含与其相关的所有割点</span><br><span class="hljs-type">int</span> stk[N], top;<br><span class="hljs-type">int</span> dfn[N], low[N], timestamp;<br><span class="hljs-type">int</span>  vdcc_cnt;<br><span class="hljs-type">bool</span> is_cut[N];<span class="hljs-comment">//是否为割点</span><br><span class="hljs-type">int</span> root;<br>vector&lt;<span class="hljs-type">int</span>&gt; sz[N];<span class="hljs-comment">//存每一个edcc</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">tarjan</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    dfn[u] = low[u] = ++ timestamp;<br>    stk[++ top] = u;<br>    <br>    <span class="hljs-keyword">if</span>(u == root &amp;&amp; h[u] == <span class="hljs-number">-1</span>)&#123;<br>        vdcc_cnt ++;<br>        sz[vdcc_cnt].<span class="hljs-built_in">push_back</span>(u);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[u]; ~i; i = ne[i])&#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span>(!dfn[j])&#123;<br>            <span class="hljs-built_in">tarjan</span>(j);<br>            low[u] = <span class="hljs-built_in">min</span>(low[u], low[j]);<br>            <span class="hljs-keyword">if</span>(dfn[u] &lt;= low[j])&#123;<br>                cnt ++;<br>                <span class="hljs-keyword">if</span> (u != root || cnt &gt; <span class="hljs-number">1</span>) is_cut[u] = <span class="hljs-literal">true</span>;<br>                ++ vdcc_cnt;<br>                <span class="hljs-type">int</span> y;<br>                <span class="hljs-keyword">do</span>&#123;<br>                    y = stk[top --];<br>                    sz[vdcc_cnt].<span class="hljs-built_in">push_back</span>(y);<br>                &#125;<span class="hljs-keyword">while</span>(y != j);<br>                sz[vdcc_cnt].<span class="hljs-built_in">push_back</span>(u);<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span> low[u] = <span class="hljs-built_in">min</span>(low[u], dfn[j]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h2><p>二分图定义：所有点在两个集合内，集合内的点之间没有边</p><p>一个图是二分图当且仅当图中不含奇数环</p><p>时间复杂度是 $O(n+m)$, n 表示点数，m 表示边数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> n;      <span class="hljs-comment">// n表示点数</span><br><span class="hljs-type">int</span> h[N], e[M], ne[M], idx;     <span class="hljs-comment">// 邻接表存储图</span><br><span class="hljs-type">int</span> color[N];       <span class="hljs-comment">// 表示每个点的颜色，-1表示未染色，0表示白色，1表示黑色</span><br><br><span class="hljs-comment">// 参数：u表示当前节点，c表示当前点的颜色</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    color[u] = c;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[u]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>    &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span> (color[j] == <span class="hljs-number">-1</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">dfs</span>(j, !c)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (color[j] == c) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(color, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> color);<br>    <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<span class="hljs-comment">//对每个点进行判断是为了防止图中含有多个连通域</span><br>        <span class="hljs-keyword">if</span> (color[i] == <span class="hljs-number">-1</span>)<br>            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">dfs</span>(i, <span class="hljs-number">0</span>))<br>            &#123;<br>                flag = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>    <span class="hljs-keyword">return</span> flag;<br>&#125;<br></code></pre></td></tr></table></figure><p>匈牙利算法</p><p>找二分图的最大匹配</p><p>时间复杂度是 $O(n<em>m)$, n 表示点数，m 表示边数 实际运行远小于$O(n</em>m)$</p><p>思想：第一个集合中的点 i 与第二个集合中的点 j 相连，如果 j 还没有匹配 或者，可以调整与j匹配的点与其他点匹配，那么 i 就与 j 匹配</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> n1, n2;     <span class="hljs-comment">// n1表示第一个集合中的点数，n2表示第二个集合中的点数</span><br><span class="hljs-type">int</span> h[N], e[M], ne[M], idx;     <span class="hljs-comment">// 邻接表存储所有边，匈牙利算法中只会用到从第一个集合指向第二个集合的边，所以这里只用存一个方向的边</span><br><span class="hljs-type">int</span> match[N];       <span class="hljs-comment">// 存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个</span><br><span class="hljs-type">bool</span> flag[N];     <span class="hljs-comment">// 表示第二个集合中的每个点是否已经被遍历过</span><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[x]; i != <span class="hljs-number">-1</span>; i = ne[i])&#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <br>        <span class="hljs-keyword">if</span>(!flag[j])&#123;<br>            flag[j] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span>(!match[j] || <span class="hljs-built_in">dfs</span>(match[j]))&#123;<br>                match[j] = x;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">// 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点</span><br><span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n1; i ++)&#123;<br>        <span class="hljs-built_in">memset</span>(flag, <span class="hljs-literal">false</span>, <span class="hljs-built_in">sizeof</span>(flag));<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(i)) res ++;<br>    &#125;<br><br></code></pre></td></tr></table></figure><p>匈牙利算法只需建从左部到右部的单向边，对左右部节点编号相不相同无限制</p><p>最小覆盖点：一张图中选出最少的点数使得所有边都至少与选出的一个点相连。</p><p>最大独立集：选出最多的点使得选出的点之间没有边。等价于选出最少的点，破坏所有的边。</p><p>以下两个针对有向无环图 (匈牙利算法都是用的无向图)</p><p>最小路径点覆盖：用最少的互不相交的路径将所有点覆盖。</p><p>最小路径重复点覆盖：用最少路径将所有点覆盖。原图求一遍传递闭包，得到新图后，在新图上求最小路径点覆盖</p><p>最大匹配数 &#x3D; 最小覆盖点数 &#x3D; 总点数 - 最大独立集数 &#x3D; 总点数 - 最小路径点覆盖数</p><h2 id="欧拉路径与欧拉回路"><a href="#欧拉路径与欧拉回路" class="headerlink" title="欧拉路径与欧拉回路"></a>欧拉路径与欧拉回路</h2><ul><li><p>对于无向图，所有边都是连通的</p><ul><li><p>存在欧拉路径的充分必要条件：度数为奇数的点只能有$0$个或$2$个</p></li><li><p>存在欧拉回路的充分必要条件：度数为奇数的点只能有$0$个</p></li></ul></li><li><p>对于有向图，所有边都是连通的</p><ul><li><p>存在欧拉路径的充分必要条件是：要么所有点的出度等于入度，要么只有两个点出度不等于入度，一个点出度等于入度加一（起点），另一个点入度等于出度加一（终点）</p></li><li><p>存在欧拉回路的充分必要条件：所有点的出度等于入度</p></li></ul></li><li><p>统计方案</p><ul><li>统计点的方案时，按照出度统计，每出去一次，在这次搜索后把这个点加入方案中，这样统计终点最后不会被统计上，逆序后加上终点即可</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//type == 1为无向图，反向边用负数表示， type等于2为有向图</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>, M = <span class="hljs-number">400010</span>;<br><span class="hljs-type">int</span> h[N], e[M], ne[M], idx;<br><span class="hljs-type">int</span> din[N], dout[M];<br><span class="hljs-type">int</span> ans[M], cnt;<br><span class="hljs-type">int</span> type, n, m;<br><span class="hljs-type">bool</span> st[M];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = b;<br>    ne[idx] = h[a];<br>    h[a] = idx ++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> &amp;i = h[u]; ~i;)&#123;<br>        <span class="hljs-keyword">if</span>(st[i])&#123;<br>            i = ne[i];<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <br>        st[i] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span>(type == <span class="hljs-number">1</span>) st[i ^ <span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br>        <br>        <span class="hljs-type">int</span> t;<br>        <span class="hljs-keyword">if</span>(type == <span class="hljs-number">1</span>)&#123;<br>            t = i / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(i &amp; <span class="hljs-number">1</span>) t = - t;<br>        &#125;<span class="hljs-keyword">else</span> t = i + <span class="hljs-number">1</span>;<br>        <br>        <span class="hljs-type">int</span> j = e[i];<br>        i = ne[i];<br>        <span class="hljs-built_in">dfs</span>(j);<br>        <br>        ans[++ cnt] = t;<br>    &#125;    <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; type &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(h));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i ++)&#123;<br>        <span class="hljs-type">int</span> a, b;<br>        cin &gt;&gt; a &gt;&gt; b;<br>        <span class="hljs-built_in">add</span>(a, b);<br>        <span class="hljs-keyword">if</span>(type == <span class="hljs-number">1</span>) <span class="hljs-built_in">add</span>(b, a);<br>        dout[a] ++, din[b] ++;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span>(type == <span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>            <span class="hljs-keyword">if</span>((din[i] + dout[i]) &amp; <span class="hljs-number">1</span>)&#123;<br>                cout &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span> &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>            <span class="hljs-keyword">if</span>(din[i] != dout[i])&#123;<br>                cout &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span> &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>        <span class="hljs-keyword">if</span>(h[i] != <span class="hljs-number">-1</span>)&#123;<br>            <span class="hljs-built_in">dfs</span>(i);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    <br>    <span class="hljs-keyword">if</span>(cnt &lt; m)&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span> &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    cout &lt;&lt; <span class="hljs-string">&quot;YES&quot;</span> &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = cnt; i; i --)<br>        cout &lt;&lt; ans[i] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="网络流"><a href="#网络流" class="headerlink" title="网络流"></a>网络流</h2><ul><li><p>最大流基本概念</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span> 基本概念<br>    <span class="hljs-number">1.1</span> 流网络，不考虑反向边<br>    <span class="hljs-number">1.2</span> 可行流，不考虑反向边<br>        <span class="hljs-number">1.2</span><span class="hljs-number">.1</span> 两个条件：容量限制、流量守恒<br>        <span class="hljs-number">1.2</span><span class="hljs-number">.2</span> 可行流的流量指从源点流出的流量 - 流入源点的流量<br>        <span class="hljs-number">1.2</span><span class="hljs-number">.3</span> 最大流是指最大可行流<br>    <span class="hljs-number">1.3</span> 残留网络，考虑反向边，残留网络的可行流f<span class="hljs-number">&#x27;</span> + 原图的可行流f = 原题的另一个可行流<br>        (<span class="hljs-number">1</span>) |f<span class="hljs-number">&#x27;</span> + f| = |f<span class="hljs-number">&#x27;</span>| + |f|<br>        (<span class="hljs-number">2</span>) |f<span class="hljs-number">&#x27;</span>| 可能是负数<br>    <span class="hljs-number">1.4</span> 增广路径<br>    <span class="hljs-number">1.5</span> 割<br>        <span class="hljs-number">1.5</span><span class="hljs-number">.1</span> 割的定义<br>        <span class="hljs-number">1.5</span><span class="hljs-number">.2</span> 割的容量，不考虑反向边，“最小割”是指容量最小的割。<br>        <span class="hljs-number">1.5</span><span class="hljs-number">.3</span> 割的流量，考虑反向边，<span class="hljs-built_in">f</span>(S, T) &lt;= <span class="hljs-built_in">c</span>(S, T)<br>        <span class="hljs-number">1.5</span><span class="hljs-number">.4</span> 对于任意可行流f，任意割[S, T]，|f| = <span class="hljs-built_in">f</span>(S, T)<br>        <span class="hljs-number">1.5</span><span class="hljs-number">.5</span> 对于任意可行流f，任意割[S, T]，|f| &lt;= <span class="hljs-built_in">c</span>(S, T)<br>        <span class="hljs-number">1.5</span><span class="hljs-number">.6</span> 最大流最小割定理<br>            (<span class="hljs-number">1</span>) 可行流f是最大流<br>            (<span class="hljs-number">2</span>) 可行流f的残留网络中不存在增广路<br>            (<span class="hljs-number">3</span>) 存在某个割[S, T]，|f| = <span class="hljs-built_in">c</span>(S, T)<br>    <span class="hljs-number">1.6</span>. 算法<br>        <span class="hljs-number">1.6</span><span class="hljs-number">.1</span> EK <span class="hljs-built_in">O</span>(nm^<span class="hljs-number">2</span>)<br>        <span class="hljs-number">1.6</span><span class="hljs-number">.2</span> Dinic <span class="hljs-built_in">O</span>(n^<span class="hljs-number">2</span>m)<br>    <span class="hljs-number">1.7</span> 应用<br>        <span class="hljs-number">1.7</span><span class="hljs-number">.1</span> 二分图<br>            (<span class="hljs-number">1</span>) 二分图匹配<br>            (<span class="hljs-number">2</span>) 二分图多重匹配<br>        <span class="hljs-number">1.7</span><span class="hljs-number">.2</span> 上下界网络流<br>            (<span class="hljs-number">1</span>) 无源汇上下界可行流<br>            (<span class="hljs-number">2</span>) 有源汇上下界最大流<br>            (<span class="hljs-number">3</span>) 有源汇上下界最小流<br>        <span class="hljs-number">1.7</span><span class="hljs-number">.3</span> 多源汇最大流<br></code></pre></td></tr></table></figure></li><li><p>EK求最大流板子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>, M = <span class="hljs-number">20010</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">int</span> h[N], e[M], w[M], ne[M], idx;<br><span class="hljs-type">int</span> maxc[N], pre[N];<br><span class="hljs-type">int</span> q[N];<br><span class="hljs-type">bool</span> st[N];<br><span class="hljs-type">int</span> n, m, S, T;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;<br>    e[idx] = a, w[idx] = <span class="hljs-number">0</span>, ne[idx] = h[b], h[b] = idx ++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(st, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(st));  <br>    <span class="hljs-type">int</span> hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">0</span>;<br>    q[<span class="hljs-number">0</span>] = S;<br>    maxc[S] = INF;<br>    st[S] = <span class="hljs-literal">true</span>;<br>    <br>    <span class="hljs-keyword">while</span>(hh &lt;= tt)&#123;<br>        <span class="hljs-type">int</span> t = q[hh ++];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[t]; ~i; i = ne[i])&#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span>(!st[j] &amp;&amp; w[i])&#123;<br>                st[j] = <span class="hljs-literal">true</span>;<br>                pre[j] = i;<br>                maxc[j] = <span class="hljs-built_in">min</span>(maxc[t], w[i]);<br>                <span class="hljs-keyword">if</span>(j == T) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                q[++ tt] = j;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">EK</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">bfs</span>())&#123;<br>        res += maxc[T];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = T; i != S; i = e[pre[i] ^ <span class="hljs-number">1</span>])<br>            w[pre[i]] -= maxc[T], w[pre[i] ^ <span class="hljs-number">1</span>] += maxc[T]; <br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;S, &amp;T);<br>    <br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(h));<br>    <span class="hljs-keyword">while</span>(m --)&#123;<br>        <span class="hljs-type">int</span> a, b, c;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);<br>        <span class="hljs-built_in">insert</span>(a, b, c);<br>    &#125;<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in">EK</span>());<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>dinic求最大流板子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs c++">理解：bfs建立分层图， 同时判断此时还有没有增广路径， 若还有增广路径， dfs找增广路径<br>dfs的过程中当前弧优化理解：对于每个点可能存在多条路径走向终点，到达每个点时都有一个流量限制，这些限制的流量，通过这个点连接的各个边<br>流向终点，若此时通过第一条边到达终点的流量限制小于当前限制说明这条边已经满流，以后再次搜索到这条边时，不必再搜，则把这个点可用的当前弧<br>转向下一条边，以此类推，因此每个点的当前弧维护的是没有满流的边，dfs中flow &lt; limit 为了维护这一性质加上这一语句<br>    <br>    <br>    <br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">10010</span>, M = <span class="hljs-number">200010</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">int</span> h[N], e[M], f[M], ne[M], idx;<br><span class="hljs-type">int</span> d[N], cur[N], q[N];<br><span class="hljs-type">int</span> n, m, S, T;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx ++;<br>    e[idx] = a, f[idx] = <span class="hljs-number">0</span>, ne[idx] = h[b], h[b] = idx ++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(d, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(d));<br>    <span class="hljs-type">int</span> hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">0</span>;<br>    q[<span class="hljs-number">0</span>] = S, d[S] = <span class="hljs-number">0</span>, cur[S] = h[S];<br>    <br>    <span class="hljs-keyword">while</span>(hh &lt;= tt)&#123;<br>        <span class="hljs-type">int</span> t = q[hh ++];<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[t]; ~i; i = ne[i])&#123;<br>            <span class="hljs-type">int</span> ver = e[i];<br>            <span class="hljs-keyword">if</span>(d[ver] == <span class="hljs-number">-1</span> &amp;&amp; f[i])&#123;<br>                d[ver] = d[t] + <span class="hljs-number">1</span>;<br>                cur[ver] = h[ver];<br>                <span class="hljs-keyword">if</span>(ver == T) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                q[++ tt] = ver;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> limit)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(u == T) <span class="hljs-keyword">return</span> limit;<br>    <br>    <span class="hljs-type">int</span> flow = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = cur[u]; ~i &amp;&amp; flow &lt; limit; i = ne[i])&#123;<br>        cur[u] = i;<br>        <span class="hljs-type">int</span> ver = e[i];<br>        <span class="hljs-keyword">if</span>(d[ver] == d[u] + <span class="hljs-number">1</span> &amp;&amp; f[i])&#123;<br>            <span class="hljs-type">int</span> t = <span class="hljs-built_in">dfs</span>(ver, <span class="hljs-built_in">min</span>(f[i], limit - flow));<br>            <span class="hljs-keyword">if</span>(!t) d[ver] = <span class="hljs-number">-1</span>;<br>            f[i] -= t, f[i ^ <span class="hljs-number">1</span>] += t, flow += t;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> flow;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dinic</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>, flow;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">bfs</span>()) <span class="hljs-keyword">while</span>(flow = <span class="hljs-built_in">dfs</span>(S, INF)) res += flow;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;   <br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>    <br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; S &gt;&gt; T;<br>    <br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(h));<br>    <span class="hljs-keyword">while</span>(m --)&#123;<br>        <span class="hljs-type">int</span> a, b, c;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br>        <span class="hljs-built_in">insert</span>(a, b, c);<br>    &#125;<br>    <br>    cout &lt;&lt; <span class="hljs-built_in">dinic</span>() &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>最大权闭合子图</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">定义：选出一些点集，这些点所连的边只会连向选出的点，选出的有此性质的点成为闭合子图；<br>   <br>解决的问题：给定一些点这些点的权值有正有负，选出一些点满足闭合子图的性质，这些点的权值最大就是最大权闭合子图。<br>建图：所有正权值的点向源点连边，容量为点权值，所有负权值的点向汇点连边，容量为点权值的绝对值，其他边容量为正无穷。<br>结论：选出的最大权闭合子图的值就是所有点权为正值的和减去最小割<br>方案：从S开始搜，搜到的点就是所有选出来的点；<br></code></pre></td></tr></table></figure></li><li><p>最大密度子图</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">定义：选出一定的点，一定的边， 每条选出的边的端点都在选出的点集里面，使得边数除以点数最大<br>    <br>解决的问题：（最一般化的问题）对于一个无向图，每个点有点权，每个边有边权，选出一些点和边， 使其满足最大密度子图的约束， 求使得选出的点权加边权除以点的个数取得最大值的选法和这个最大值<br>建图：每个从源点连一条正向容量为U反向为<span class="hljs-number">0</span>的边，向汇点连一条正向U + <span class="hljs-number">2</span> * g - dg[i] - <span class="hljs-number">2</span> * p[i]反向为<span class="hljs-number">0</span>的边，其余边都是正反为边权<br>结论：二分g, C[S, T] = U * n - （要最大化的式子 * <span class="hljs-number">2</span>）<br>注意: U要使得<span class="hljs-number">2</span> * g - dg[i] - <span class="hljs-number">2</span> * p[i] (dg[i] 为每个点连接的所有边的边权， p[i]为点权)，最大化的式子有g要二分<br></code></pre></td></tr></table></figure></li><li><p>最小权覆盖集</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">适用于二分图， 一般的图暴搜<br>定义：对于一张二分图，每个点有权值，选出一些点，使得这些点的权值之和最小并且每条边的端点至少包含一个被选出的点（点权非负）<br>解决的问题：同定义<br>建图：二分图左边的点连向源点，右边的点连向汇点，容量为点权值， 中间点与点容量为INF；<br>结论：最小割就是最小权覆盖<br>如何找方案：先找出最小割，从S开始搜，沿着容量大于<span class="hljs-number">0</span>的边搜，划分S, T集合，枚举正向边，若一条边容量为空 其为割边，这时判断起点在S集合还是T集合即可<br></code></pre></td></tr></table></figure></li><li><p>最大独立集</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">适用于二分图，一般图暴搜<br>定义：对于一张无向图，每个点有权值，选出一些点，使得这些点之间没有边，并且点的权值之和最大<br>解决的问题：同定义<br>建图：同最小权覆盖<br>结论：所有点的权值之和减去最小权覆盖<br></code></pre></td></tr></table></figure></li><li><p>费用流</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs c++">定义：给定一个流网络，每条边除了有容量限制，还有单位流量费用，求最大流的最小费用或最大费用<br>算法：SSP,就是把EK增广的函数换成spfa，按照边权是费用求最短路径<br>核心思想：每次增广可行流，都用费用最便宜/最贵的边<br> <br>最小费用流模板：<br>    <br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">5010</span>, M = <span class="hljs-number">100010</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">int</span> h[N], e[M], f[M], w[M], ne[M], idx;<br><span class="hljs-type">int</span> d[N], pre[M], maxc[N], q[N];<br><span class="hljs-type">int</span> n, m, S, T;<br><span class="hljs-type">bool</span> st[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c, <span class="hljs-type">int</span> d)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = b, f[idx] = c, w[idx] = d, ne[idx] = h[a], h[a] = idx ++;<br>    e[idx] = a, f[idx] = <span class="hljs-number">0</span>, w[idx] = -d, ne[idx] = h[b], h[b] = idx ++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(d, <span class="hljs-number">0x3f</span>, <span class="hljs-built_in">sizeof</span>(d));<br>    <span class="hljs-built_in">memset</span>(maxc, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(maxc));<br>    <span class="hljs-built_in">memset</span>(st, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(st));<br>    <span class="hljs-type">int</span> hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">1</span>;<br>    q[<span class="hljs-number">0</span>] = S, d[S] = <span class="hljs-number">0</span>, maxc[S] = INF;<br><br>    <span class="hljs-keyword">while</span>(hh != tt)&#123;<br>        <span class="hljs-type">int</span> t = q[hh ++];<br>        <span class="hljs-keyword">if</span>(hh == N) hh = <span class="hljs-number">0</span>;<br>        st[t] = <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[t]; ~i; i = ne[i])&#123;<br>            <span class="hljs-type">int</span> ver = e[i];<br>            <span class="hljs-keyword">if</span>(f[i] &amp;&amp; d[ver] &gt; d[t] + w[i])&#123;<br>                d[ver] = d[t] + w[i];<br>                pre[ver] = i;<br>                maxc[ver] = <span class="hljs-built_in">min</span>(maxc[t], f[i]);<br>                <span class="hljs-keyword">if</span>(!st[ver])&#123;<br>                    q[tt ++] = ver;<br>                    <span class="hljs-keyword">if</span>(tt == N) tt = <span class="hljs-number">0</span>;<br>                    st[ver] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> maxc[T] &gt; <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EK</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;flow, <span class="hljs-type">int</span> &amp;cost)</span></span><br><span class="hljs-function"></span>&#123;<br>    flow = cost = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">spfa</span>())&#123;<br>        <span class="hljs-type">int</span> t = maxc[T];<br>        flow += t;<br>        cost += t * d[T];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = T; i != S; i = e[pre[i] ^ <span class="hljs-number">1</span>])<br>            f[pre[i]] -= t, f[pre[i] ^ <span class="hljs-number">1</span>] += t;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; S &gt;&gt; T;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(h));<br>    <span class="hljs-keyword">while</span>(m --)&#123;<br>        <span class="hljs-type">int</span> a, b, c, d;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;<br>        <span class="hljs-built_in">insert</span>(a, b, c, d);<br>    &#125;<br><br>    <span class="hljs-type">int</span> flow, cost;<br>    <span class="hljs-built_in">EK</span>(flow, cost);<br><br>    cout &lt;&lt; flow &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; cost &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="四、数学知识"><a href="#四、数学知识" class="headerlink" title="四、数学知识"></a>四、数学知识</h1><h2 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h2><p>试除法判断质数 </p><p>时间复杂度 $O(\sqrt{n})$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_prime</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= x / i; i ++ )<br>        <span class="hljs-keyword">if</span> (x % i == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>试除法分解质因数</p><p>时间复杂度 最坏$O(\sqrt{n})$</p><p>一个数最多只有一个大于sqrt(n)的质因数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">divide</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= x / i; i ++ )<br>        <span class="hljs-keyword">if</span> (x % i == <span class="hljs-number">0</span>)<span class="hljs-comment">//x中此时没有小于i的质因数</span><br>        &#123;<span class="hljs-comment">//此式子成立，i中也不包含小于i的质因数 ,则i一定为质数</span><br>            <span class="hljs-type">int</span> s = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (x % i == <span class="hljs-number">0</span>) x /= i, s ++ ;<br>            cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; s &lt;&lt; endl;<br>        &#125;<br>    <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">1</span>) cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; <span class="hljs-number">1</span> &lt;&lt; endl;<br>    cout &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>筛质数</p><p>欧拉筛（线性筛选）</p><p>时间复杂度$O(n)$</p><p>核心思想：一个数只被它的最小质因子筛掉</p><p>一个合数可以表示成一个最小质因子x乘以另一个数k，</p><p>分别枚举最小质数x和另一个数k把它们的乘积标记为合数,</p><p>此时如果k中也含有因数x，则停止，因为下一个质因子x与k相乘后的合数的最小质因子是上一个x</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> primes[N], cnt;     <span class="hljs-comment">// primes[]存储所有素数</span><br><span class="hljs-type">bool</span> flag[N];         <span class="hljs-comment">// flag[x]存储x是否被筛掉</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">get_primes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">if</span> (!flag[i]) primes[cnt ++ ] = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; primes[j] &lt;= n / i; j ++ )<span class="hljs-comment">//条件不用写 j &lt;= cnt, </span><br>        &#123;<span class="hljs-comment">//i 为质数，primes[j] = i 时会停下来</span><br>            flag[primes[j] * i] = <span class="hljs-literal">true</span>;<span class="hljs-comment">//i为合数，primes[j] 为i最小质因子也会停下来</span><br>            <span class="hljs-keyword">if</span> (i % primes[j] == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>线性筛选</p><p>思想：把每个质数的倍数筛选掉</p><p>时间复杂度$O( nlog(logn))$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> primes[N], cnt;     <span class="hljs-comment">// primes[]存储所有素数</span><br><span class="hljs-type">bool</span> flag[N];         <span class="hljs-comment">// flag[x]存储x是否被筛掉</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_primes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i ++)&#123;<br>        <span class="hljs-keyword">if</span>(!flag[i])&#123; <br>            primes[cnt ++] = i;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i + i; j &lt;= n; j += i) flag[j] = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>试除法求所有约数</p><p>时间复杂度 $ O(\sqrt{n})$</p><p>约数成对出现，求小的即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">get_divisors</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= x / i; i ++ )<br>        <span class="hljs-keyword">if</span> (x % i == <span class="hljs-number">0</span>)<br>        &#123;<br>            res.<span class="hljs-built_in">push_back</span>(i);<br>            <span class="hljs-keyword">if</span> (i != x / i) res.<span class="hljs-built_in">push_back</span>(x / i);<br>        &#125;<br>    <span class="hljs-built_in">sort</span>(res.<span class="hljs-built_in">begin</span>(), res.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>约数个数和约数之和</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">如果 N = p1^c1 * p2^c2 * ... *pk^ck<br>约数个数： (c1 + <span class="hljs-number">1</span>) * (c2 + <span class="hljs-number">1</span>) * ... * (ck + <span class="hljs-number">1</span>)<br>约数之和： (p1^<span class="hljs-number">0</span> + p1^<span class="hljs-number">1</span> + ... + p1^c1) * ... * (pk^<span class="hljs-number">0</span> + pk^<span class="hljs-number">1</span> + ... + pk^ck)<br><br></code></pre></td></tr></table></figure><p>欧几里得算法求最大公约数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> b ? <span class="hljs-built_in">gcd</span>(b, a % b) : a;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h2><p>定义：1~n中与n互质的数的个数</p><p>n分界质因数后 所有质因数为p1， p2，… ，pk;<br>$$<br>res &#x3D; n * (1 - 1 &#x2F; p1)(1 - 1 &#x2F; p2)…(1 - 1&#x2F; pk);<br>$$<br>只与质因子有关，与质因子个数无关</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">phi</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> res = x;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= x / i; i ++ )<br>        <span class="hljs-keyword">if</span> (x % i == <span class="hljs-number">0</span>)<br>        &#123;<br>            res = res / i * (i - <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">while</span> (x % i == <span class="hljs-number">0</span>) x /= i;<br>        &#125;<br>    <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">1</span>) res = res / x * (x - <span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>线性筛求欧拉函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">质数i的欧拉函数等于i - 1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">质数primes[j]乘以i的欧拉函数</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">1、若i % primes[j] == 0, 为primes[j] * phi(i)</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">2、若i % primes[j] != 0, 为（primes[j] - 1）* phi(i)</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">欧拉定理 若a 与 n互质 则 a ^ phi(n) mod n = 1</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-type">int</span> primes[N], cnt;     <span class="hljs-comment">// primes[]存储所有素数</span><br><span class="hljs-type">int</span> euler[N];           <span class="hljs-comment">// 存储每个数的欧拉函数</span><br><span class="hljs-type">bool</span> st[N];         <span class="hljs-comment">// st[x]存储x是否被筛掉</span><br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_eulers</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    euler[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">if</span> (!st[i])<br>        &#123;<br>            primes[cnt ++ ] = i;<br>            euler[i] = i - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; primes[j] &lt;= n / i; j ++ )<br>        &#123;<br>            <span class="hljs-type">int</span> t = primes[j] * i;<br>            st[t] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (i % primes[j] == <span class="hljs-number">0</span>)<br>            &#123;<br>                euler[t] = euler[i] * primes[j];<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            euler[t] = euler[i] * (primes[j] - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><ul><li>数的快速幂</li></ul><p>求 m^k mod p，时间复杂度$ O(logk)$。</p><p>k的二进制表示u位是1就 乘以$m^{2^u}$次方</p><p>$m^{2^u}$等于$m^{2^{u-1}}$的平方，k算到下一位，也要相应的把这个数更新</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++">求 m^k mod p，时间复杂度 <span class="hljs-built_in">O</span>(logk)。<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qmi</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">1</span> % p, t = m;<br>    <span class="hljs-keyword">while</span> (k)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (k&amp;<span class="hljs-number">1</span>) res = res * t % p;<br>        t = t * t % p;<br>        k &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>快速幂求逆元，b与p（p是质数）互质 b的逆元为b^(p - 2);</p><ul><li><p>矩阵快速幂</p><p>$f[n] &#x3D; f[0] * A ^ n;$ </p><p>A是一个矩阵，结合相邻两项的关系即可得到矩阵，注意矩阵中不能由变量</p></li></ul><h2 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a>扩展欧几里得算法</h2><p>裴蜀定理 ：对于任意正整数a, b， 一定存在非0正整数x, y使得<br>$$<br>ax + by &#x3D; gcd（a，b）<br>$$</p><p>理解：a，b是gcd（a，b）的倍数，则a，b线性组合的正数也一定是gcd（a，b）的倍数，最小是一倍</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">exgcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> &amp;x, <span class="hljs-type">int</span> &amp;y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(!b)&#123;<br>        x = <span class="hljs-number">1</span>, y = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125; <br>    <br>    <span class="hljs-type">int</span> d = <span class="hljs-built_in">exgcd</span>(b, a % b, y, x);<br>    y -= a / b * x;<br>    <br>    <span class="hljs-keyword">return</span> d;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++">x 同余 a1 mod m1<br>x 同余 a2 mod m2<br>    .<br>    .<br>    .<br>    <br>x 同余 ak mod mk<br><br>    m1 m2...mk两两互质<br>    M = m1 * m2*...*mk<br>    Mi = M / mi<br>    ti是Mi模mi的乘法逆元<br>    x0 = a1 * M1 * t1 + a2 * M2 * t2 +...+ ak * Mk * tk;<br>x 通解 x = x0 + k * M; <br></code></pre></td></tr></table></figure><h2 id="求组合数"><a href="#求组合数" class="headerlink" title="求组合数"></a>求组合数</h2><p>- </p><p>$1≤n≤10000$<br>$1≤b≤a≤2000$</p><p>递归求解</p><p>总共只有$2000^2$中组合，预处理查表即可</p><p>时间复杂度$O(n^2)$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i ++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= i; j ++)<br>            <span class="hljs-keyword">if</span>(!j) c[i][j] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> c[i][j] = (c[i - <span class="hljs-number">1</span>][j] + c[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]) % mod;<br></code></pre></td></tr></table></figure><p>- </p><p>$1≤n≤10000$<br>$1≤b≤a≤10^5$</p><p>预处理出每个组合数会超时，此时按照组合数的定义求，预处理出每个数的阶乘和每个数阶乘的逆元(都是取余后的结果)</p><p>注意：$(a &#x2F; b) mod p !&#x3D; (a mod p) &#x2F; (b mod p)$,但b化为逆元后就可以先分别取余再相乘，因为化为逆元后除法变为乘法</p><p>时间复杂度$O(nlogn$)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++">首先预处理出所有阶乘取模的余数fact[N]，以及所有阶乘取模的逆元infact[N]<br>如果取模的数是质数，可以用费马小定理求逆元<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qmi</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> p)</span>    <span class="hljs-comment">// 快速幂模板</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (k)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (k &amp; <span class="hljs-number">1</span>) res = (LL)res * a % p;<br>        a = (LL)a * a % p;<br>        k &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">// 预处理阶乘的余数和阶乘逆元的余数</span><br>fact[<span class="hljs-number">0</span>] = infact[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; N; i ++ )<br>&#123;<br>    fact[i] = (LL)fact[i - <span class="hljs-number">1</span>] * i % mod;<br>    infact[i] = (LL)infact[i - <span class="hljs-number">1</span>] * <span class="hljs-built_in">qmi</span>(i, mod - <span class="hljs-number">2</span>, mod) % mod;<br>&#125;<br></code></pre></td></tr></table></figure><p>- </p><p>$1≤n≤20$<br>$1≤b≤a≤10^{18}$<br>$1≤p≤10^5$</p><p>时间复杂度$O(logp(n) * p * logp)$</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c">若p是质数，则对于任意整数 <span class="hljs-number">1</span> &lt;= m &lt;= n，有：<br>    C(n, m) = C(n % p, m % p) * C(n / p, m / p) (mod p)<br>C(n % p, m % p)直接算，C(n / p, m / p) (mod p)继续用lucas定理<br><span class="hljs-type">int</span> qmi(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> p)  <span class="hljs-comment">// 快速幂模板</span><br>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">1</span> % p;<br>    <span class="hljs-keyword">while</span> (k)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (k &amp; <span class="hljs-number">1</span>) res = (LL)res * a % p;<br>        a = (LL)a * a % p;<br>        k &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">C</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> p)</span>  <span class="hljs-comment">// 通过定理求组合数C(a, b)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (a &lt; b) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    LL x = <span class="hljs-number">1</span>, y = <span class="hljs-number">1</span>;  <span class="hljs-comment">// x是分子，y是分母</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = a, j = <span class="hljs-number">1</span>; j &lt;= b; i --, j ++ )<br>    &#123;<br>        x = (LL)x * i % p;<br>        y = (LL) y * j % p;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> x * (LL)qmi(y, p - <span class="hljs-number">2</span>, p) % p;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">lucas</span><span class="hljs-params">(LL a, LL b, <span class="hljs-type">int</span> p)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (a &lt; p &amp;&amp; b &lt; p) <span class="hljs-keyword">return</span> C(a, b, p);<br>    <span class="hljs-keyword">return</span> (LL)C(a % p, b % p, p) * lucas(a / p, b / p, p) % p;<br>&#125;<br></code></pre></td></tr></table></figure><p>- </p><p>把最终的结果不取余，输出出来</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs c++">当我们需要求出组合数的真实值，而非对某个数的余数时，分解质因数的方式比较好用：<br>    <span class="hljs-number">1.</span> 筛法求出范围内的所有质数<br>    <span class="hljs-number">2.</span> 通过 <span class="hljs-built_in">C</span>(a, b) = a! / b! / (a - b)! 这个公式求出每个质因子的次数。 n! 中p的次数是 n / p + n / p^<span class="hljs-number">2</span> + n / p^<span class="hljs-number">3</span> + ...<br>    <span class="hljs-number">3.</span> 用高精度乘法将所有质因子相乘<br><br><span class="hljs-type">int</span> primes[N], cnt;     <span class="hljs-comment">// 存储所有质数</span><br><span class="hljs-type">int</span> sum[N];     <span class="hljs-comment">// 存储每个质数的次数</span><br><span class="hljs-type">bool</span> st[N];     <span class="hljs-comment">// 存储每个数是否已被筛掉</span><br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_primes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>      <span class="hljs-comment">// 线性筛法求素数</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">if</span> (!st[i]) primes[cnt ++ ] = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; primes[j] &lt;= n / i; j ++ )<br>        &#123;<br>            st[primes[j] * i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (i % primes[j] == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> p)</span>       <span class="hljs-comment">// 求n！中的次数</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (n)<br>    &#123;<br>        res += n / p;<br>        n /= p;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">mul</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; a, <span class="hljs-type">int</span> b)</span>       <span class="hljs-comment">// 高精度乘低精度模板</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; c;<br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; a.<span class="hljs-built_in">size</span>(); i ++ )<br>    &#123;<br>        t += a[i] * b;<br>        c.<span class="hljs-built_in">push_back</span>(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (t)<br>    &#123;<br>        c.<span class="hljs-built_in">push_back</span>(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> c;<br>&#125;<br><br><span class="hljs-built_in">get_primes</span>(a);  <span class="hljs-comment">// 预处理范围内的所有质数</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; cnt; i ++ )     <span class="hljs-comment">// 求每个质因数的次数</span><br>&#123;<br>    <span class="hljs-type">int</span> p = primes[i];<br>    sum[i] = <span class="hljs-built_in">get</span>(a, p) - <span class="hljs-built_in">get</span>(b, p) - <span class="hljs-built_in">get</span>(a - b, p);<br>&#125;<br><br>vector&lt;<span class="hljs-type">int</span>&gt; res;<br>res.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; cnt; i ++ )     <span class="hljs-comment">// 用高精度乘法将所有质因子相乘</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; sum[i]; j ++ )<br>        res = <span class="hljs-built_in">mul</span>(res, primes[i]);<br><br><br><br></code></pre></td></tr></table></figure><h2 id="卡特兰数"><a href="#卡特兰数" class="headerlink" title="卡特兰数"></a>卡特兰数</h2><p>$$<br>\frac{C^{n}_{2 * n}}{n + 1}<br>$$</p><p>给定 n 个 0 和 n 个 1，它们将按照某种顺序排成长度为 2n 的序列，求它们能排列成的所有序列中，能够满足任意前缀序列中 0 的个数都不少于1 的个数的序列,数量就是卡特兰数</p><h2 id="高斯消元"><a href="#高斯消元" class="headerlink" title="高斯消元"></a>高斯消元</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">110</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-6</span>;<br><span class="hljs-type">double</span> a[N][N];<br><span class="hljs-type">int</span> n;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gauss</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> r, c;<br>    <span class="hljs-keyword">for</span>(r = <span class="hljs-number">0</span>, c = <span class="hljs-number">0</span>; c &lt; n; c ++)&#123;<br>        <span class="hljs-type">int</span> t = r;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = r + <span class="hljs-number">1</span>; i &lt; n; i ++)<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(a[i][c]) &gt; <span class="hljs-built_in">fabs</span>(a[t][c]))<br>                t = i;<br>                <br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(a[t][c]) &lt; eps) <span class="hljs-keyword">continue</span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n + <span class="hljs-number">1</span>; i ++) <span class="hljs-built_in">swap</span>(a[t][i], a[r][i]);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n; i &gt;= c; i --) a[r][i] /= a[r][c];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = r + <span class="hljs-number">1</span>; i &lt; n; i ++)<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(a[i][c]) &gt; eps)<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = n; j &gt;= c; j --)&#123;<br>                    a[i][j] -= a[r][j] * a[i][c]; <br>                &#125;<br>        <br>        r ++;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i --)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j ++)<br>            a[i][n] -= a[i][j] * a[j][n];<br>    <br>    <span class="hljs-keyword">if</span>(r &lt; n)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = r; i &lt; n; i ++)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(a[i][n]) &gt; eps) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        &#125;    <br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="容斥原理"><a href="#容斥原理" class="headerlink" title="容斥原理"></a>容斥原理</h2><p>在<a href="https://baike.baidu.com/item/%E8%AE%A1%E6%95%B0/9276342">计数</a>时，必须注意没有重复，没有遗漏。为了使<a href="https://baike.baidu.com/item/%E9%87%8D%E5%8F%A0/9009438">重叠</a>部分不被重复计算，人们研究出一种新的计数方法，这种方法的基本思想是：先不考虑重叠的情况，把包含于某内容中的所有对象的数目先计算出来，然后再把计数时重复计算的数目<a href="https://baike.baidu.com/item/%E6%8E%92%E6%96%A5/10717656">排斥</a>出去，使得计算的结果既无遗漏又无重复，这种计数的方法称为容斥原理。</p><p>选择的个体的个数是奇数就加，是偶数就减</p><h2 id="博弈论"><a href="#博弈论" class="headerlink" title="博弈论"></a>博弈论</h2><p>NIM游戏<br>给定N堆物品，第i堆物品有Ai个。两名玩家轮流行动，每次可以任选一堆，取走任意多个物品，可把一堆取光，但不能不取。取走最后一件物品者获胜。两人都采取最优策略，问先手是否必胜。</p><p>我们把这种游戏称为NIM博弈。把游戏过程中面临的状态称为局面。整局游戏第一个行动的称为先手，第二个行动的称为后手。若在某一局面下无论采取何种行动，都会输掉游戏，则称该局面必败。<br>所谓采取最优策略是指，若在某一局面下存在某种行动，使得行动后对面面临必败局面，则优先采取该行动。同时，这样的局面被称为必胜。我们讨论的博弈问题一般都只考虑理想情况，即两人均无失误，都采取最优策略行动时游戏的结果。<br>NIM博弈不存在平局，只有先手必胜和先手必败两种情况。</p><p>定理： NIM博弈先手必胜，当且仅当 A1 ^ A2 ^ … ^ An !&#x3D; 0</p><p>公平组合游戏ICG<br>若一个游戏满足：</p><p>由两名玩家交替行动；<br>在游戏进程的任意时刻，可以执行的合法行动与轮到哪名玩家无关；<br>不能行动的玩家判负；<br>则称该游戏为一个公平组合游戏。<br>NIM博弈属于公平组合游戏，但城建的棋类游戏，比如围棋，就不是公平组合游戏。因为围棋交战双方分别只能落黑子和白子，胜负判定也比较复杂，不满足条件2和条件3。</p><p>有向图游戏<br>给定一个有向无环图，图中有一个唯一的起点，在起点上放有一枚棋子。两名玩家交替地把这枚棋子沿有向边进行移动，每次可以移动一步，无法移动者判负。该游戏被称为有向图游戏。<br>任何一个公平组合游戏都可以转化为有向图游戏。具体方法是，把每个局面看成图中的一个节点，并且从每个局面向沿着合法行动能够到达的下一个局面连有向边。</p><p>Mex运算<br>设S表示一个非负整数集合。定义mex(S)为求出不属于集合S的最小非负整数的运算，即：<br>mex(S) &#x3D; min{x}, x属于自然数，且x不属于S</p><p>SG函数<br>在有向图游戏中，对于每个节点x，设从x出发共有k条有向边，分别到达节点y1, y2, …, yk，定义SG(x)为x的后继节点y1, y2, …, yk 的SG函数值构成的集合再执行mex(S)运算的结果，即：<br>SG(x) &#x3D; mex({SG(y1), SG(y2), …, SG(yk)})<br>特别地，整个有向图游戏G的SG函数值被定义为有向图游戏起点s的SG函数值，即SG(G) &#x3D; SG(s)。</p><p>有向图游戏的和<br>设G1, G2, …, Gm 是m个有向图游戏。定义有向图游戏G，它的行动规则是任选某个有向图游戏Gi，并在Gi上行动一步。G被称为有向图游戏G1, G2, …, Gm的和。<br>有向图游戏的和的SG函数值等于它包含的各个子游戏SG函数值的异或和，即：<br>SG(G) &#x3D; SG(G1) ^ SG(G2) ^ … ^ SG(Gm)</p><p>定理<br>有向图游戏的某个局面必胜，当且仅当该局面对应节点的SG函数值大于0。<br>有向图游戏的某个局面必败，当且仅当该局面对应节点的SG函数值等于0。</p><h1 id="五、动态规划"><a href="#五、动态规划" class="headerlink" title="五、动态规划"></a>五、动态规划</h1><h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><ul><li>01背包问题</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m; j &gt;= v[i]; j --)<br>           f[j] = <span class="hljs-built_in">max</span>(f[j], f[j - v[i]] + w[i]);<br></code></pre></td></tr></table></figure><ul><li>完全背包问题</li></ul><p>每件物品可以取无限个</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n ; i ++)<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = v[i]; j &lt;= V; j ++)<br>    f[j] = <span class="hljs-built_in">max</span>(f[j], f[j - v[i]] + w[i])<br></code></pre></td></tr></table></figure><ul><li>多重背包</li></ul><p>时间复杂度 ：$O( N * V * logs)$</p><p>空间要开$ N * log s$</p><p>每件物品有个数限制</p><p>二进制优化核心思想：把一定数量的物品打包成一件，转化成01背包问题</p><p>假设一件物品有$s$件， $1 + 2 + … 2^k &lt; s   1 + 2 + … 2^k  + c &#x3D; s   c &lt; 2^{k + 1}$</p><p>$1 , 2 + … 2^k$  , $c$可以组合出任意小于等于$s $的数，则就把有$n$件物品的多重背包问题转化为有$n*logs$的01背包问题 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//二进制优化</span><br><span class="hljs-type">int</span> n, V;<span class="hljs-comment">//物品数量，背包最大容量</span><br><span class="hljs-type">int</span> v[N], w[N];<br><span class="hljs-type">int</span> f[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; V;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)&#123;<br>        <span class="hljs-type">int</span> a, b, s;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; s;<br>        <span class="hljs-type">int</span> k = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(k &lt;= s)&#123;<br>            cnt ++;<br>            v[cnt] = k * a;<br>            w[cnt] = k * b;<br>            s -= k;<br>            k *= <span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(s &gt; <span class="hljs-number">0</span>)&#123;<br>            cnt ++;<br>            v[cnt] = s * a;<br>            w[cnt] = s * b;<br>        &#125;<br>    &#125;<br>    n = cnt;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = V; j &gt;= v[i]; j --)<br>            f[j] = <span class="hljs-built_in">max</span>(f[j], f[j - v[i]] + w[i]);<br><span class="hljs-comment">//单调队列优化</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">40010</span>;<br><span class="hljs-type">int</span> f[N], q[N];<br><span class="hljs-type">int</span> last_f[N];<br><span class="hljs-type">int</span> n, m;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;   <br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)&#123;<br>        <span class="hljs-type">int</span> v, w, s;<br>        cin &gt;&gt; v &gt;&gt; w &gt;&gt; s;<br><br>        <span class="hljs-built_in">memcpy</span>(last_f, f, <span class="hljs-built_in">sizeof</span>(f));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> r = <span class="hljs-number">0</span>; r &lt; v;  r ++)&#123;<br>            <span class="hljs-type">int</span> hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = r; j &lt;= m; j += v)&#123;<br>                <span class="hljs-keyword">if</span>(hh &lt;= tt &amp;&amp; q[hh] &lt; j - s * v) hh ++;<br>                <span class="hljs-keyword">while</span>(hh &lt;= tt &amp;&amp; last_f[q[tt]] + (j - q[tt]) / v * w &lt;= last_f[j]) tt --;<br>                q[++ tt] = j;<br>                f[j] = <span class="hljs-built_in">max</span>(f[j], last_f[q[hh]] + (j - q[hh]) / v * w);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    cout &lt;&lt; f[m] &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;            <br></code></pre></td></tr></table></figure><ul><li>分组背包问题</li></ul><p>​物品分为几组, 每个组中只能选择一个物品</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//枚举每组物品，</span><br><span class="hljs-comment">//更新每组，用的是前一组数据，因此容量从大到小枚举</span><br> <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = V; j &gt;= <span class="hljs-number">0</span>; j --)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt;= s[i]; k ++)<br>                <span class="hljs-keyword">if</span>(v[i][k] &lt;= j) f[j] = <span class="hljs-built_in">max</span>(f[j], f[j - v[i][k]] + w[i][k]);<br></code></pre></td></tr></table></figure><ul><li><p>背包问题求方案数</p><ul><li>求体积恰好装到一定容量的方案数，这种的一般都是价值等于体积，体积可以直接代表价值，因此可以确定状态从哪里转移过来。<br>只需要把状态转移从求最大值换成求和即可。</li><li>求最优方案的方案数，记录最大价值同时也要记录此时的方案数，因此要多开一个数组，方案数转移的时候要确定是从哪个状态转移过来的，<br>把转移过来的方案数加上即可。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">第 i 件物品的体积是 vi，价值是 wi。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">输出 最优选法的方案数。注意答案可能很大，请输出答案模 10^9+7 的结果。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>, mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-type">int</span> f[N];<br><span class="hljs-type">int</span> g[N];<br><span class="hljs-type">int</span> n, m;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    g[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)&#123;<br>        <span class="hljs-type">int</span> v, w;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;v, &amp;w);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m; j &gt;= v; j --)&#123;<br>            <span class="hljs-type">int</span> maxw = <span class="hljs-built_in">max</span>(f[j], f[j - v] + w);<br>            <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span>(f[j] == maxw) cnt = g[j];<br>            <span class="hljs-keyword">if</span>(f[j - v] + w == maxw) cnt = (cnt + g[j - v]) % mod;<br>            g[j] = cnt % mod;<br>            f[j] = maxw;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> maxn = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= m; i ++) maxn = <span class="hljs-built_in">max</span>(maxn, f[i]);<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= m; i ++)<br>        <span class="hljs-keyword">if</span>(f[i] == maxn) cnt = (cnt + g[i]) % mod;<br>        <br>    cout &lt;&lt; cnt &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>背包问题求具体方案</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">第 i 件物品的体积是 vi，价值是 wi。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">输出 字典序最小的方案。这里的字典序是指：所选物品的编号所构成的序列。物品的编号范围是 1…N。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><span class="hljs-type">int</span> f[N][N];<br><span class="hljs-type">int</span> v[N], w[N];<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">不能倒着从后往前推每个物品选不选</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) cin &gt;&gt; v[i] &gt;&gt; w[i];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n; i; i --)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= m; j ++)&#123;<br>            f[i][j] = f[i + <span class="hljs-number">1</span>][j];<br>            <span class="hljs-keyword">if</span>(j &gt;= v[i]) f[i][j] = <span class="hljs-built_in">max</span>(f[i][j], f[i + <span class="hljs-number">1</span>][j - v[i]] + w[i]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//f[1][m]是最大值</span><br>    <span class="hljs-type">int</span> j = m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)&#123;<br>        <span class="hljs-keyword">if</span>(j &gt;= v[i] &amp;&amp; f[i][j] == f[i + <span class="hljs-number">1</span>][j - v[i]] + w[i])&#123;<br>            cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>            j -= v[i];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="线性dp"><a href="#线性dp" class="headerlink" title="线性dp"></a>线性dp</h2><ul><li><p>LIS</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>， -INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">int</span> a[N];<br><span class="hljs-type">int</span> q[N];<br><span class="hljs-type">int</span> n;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]);<br>    <br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<span class="hljs-comment">//表示当前已经找到了长度为cnt的上升子序列</span><br>    q[<span class="hljs-number">0</span>] = -INF;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)&#123;<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = cnt;<br>        <span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>            <span class="hljs-type">int</span> mid = l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>;<br>            <br>            <span class="hljs-keyword">if</span>(q[mid] &lt; a[i]) l = mid;<br>            <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>        cnt = <span class="hljs-built_in">max</span>(cnt, r + <span class="hljs-number">1</span>);<br>        q[r + <span class="hljs-number">1</span>] = a[i];<br>    &#125;<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, cnt);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>LCS</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br>string a, b;<br><span class="hljs-type">int</span> dp[N][N];<br><span class="hljs-type">int</span> n, m;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    cin &gt;&gt; a &gt;&gt; b;<br>    a = <span class="hljs-string">&quot; &quot;</span> + a, b = <span class="hljs-string">&quot; &quot;</span> + b;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++)&#123;<br>           dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]);<br>           <span class="hljs-keyword">if</span>(a[i] == b[j]) dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>        &#125;<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, dp[n][m]);<br>            <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>LCIS</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">3010</span>;<br><span class="hljs-type">int</span> a[N], b[N];<br><span class="hljs-type">int</span> dp[N][N];<br><span class="hljs-type">int</span> n;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;b[i]);<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)&#123;<br>        <span class="hljs-type">int</span> maxv = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++)&#123;<br>            dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>            <span class="hljs-keyword">if</span>(a[i] == b[j]) dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j], maxv);<br>            <span class="hljs-keyword">if</span>(b[j] &lt; a[i]) maxv = <span class="hljs-built_in">max</span>(maxv, dp[i - <span class="hljs-number">1</span>][j] + <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">            &#123;</span><br><span class="hljs-comment">                dp[i][j] = max(dp[i][j], 1);</span><br><span class="hljs-comment">                for(int k = 1; k &lt; j; k ++)</span><br><span class="hljs-comment">                    if(b[k] &lt; a[i])</span><br><span class="hljs-comment">                        dp[i][j] = max(dp[i][j], dp[i - 1][k] + 1);</span><br><span class="hljs-comment">            &#125;</span><br><span class="hljs-comment">            */</span><br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) res = <span class="hljs-built_in">max</span>(res, dp[n][i]);<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, res);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="区间dp"><a href="#区间dp" class="headerlink" title="区间dp"></a>区间dp</h2><p>状态为一个区间的状态，通常枚举区间长度，再枚举区间起点</p><p>常用技巧：</p><ul><li>破环成链</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">AcWing 1068. 环形石子合并</span><br><span class="hljs-comment">将 n 堆石子绕圆形操场排放，现要将石子有序地合并成一堆。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">规定每次只能选相邻的两堆合并成新的一堆，并将新的一堆的石子数记做该次合并的得分。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">请编写一个程序，读入堆数 n 及每堆的石子数，并进行如下计算：</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">选择一种合并石子的方案，使得做 n−1 次合并得分总和最大。</span><br><span class="hljs-comment">选择一种合并石子的方案，使得做 n−1 次合并得分总和最小。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&quot;\n&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">410</span>;<br><span class="hljs-type">int</span> s[N];<br><span class="hljs-type">int</span> a[N];<br><span class="hljs-type">int</span> f1[N][N], f2[N][N];<br><span class="hljs-type">int</span> n;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)&#123;<br>        cin &gt;&gt; a[i];<br>        a[n + i] = a[i];<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n * <span class="hljs-number">2</span>; i ++) s[i] = a[i] + s[i - <span class="hljs-number">1</span>];<br><br>    <span class="hljs-built_in">memset</span>(f1, <span class="hljs-number">0x3f</span>, <span class="hljs-built_in">sizeof</span>(f1));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> len = <span class="hljs-number">1</span>; len &lt;= n * <span class="hljs-number">2</span>; len ++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l = <span class="hljs-number">1</span>; l + len - <span class="hljs-number">1</span> &lt;= n * <span class="hljs-number">2</span>; l ++)&#123;<br>            <span class="hljs-type">int</span> r = l + len - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(len == <span class="hljs-number">1</span>) f1[l][r] = f2[l][r] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = l; k &lt; r; k ++)<br>                    f1[l][r] = <span class="hljs-built_in">min</span>(f1[l][r], f1[l][k] + f1[k + <span class="hljs-number">1</span>][r] + s[r] - s[l - <span class="hljs-number">1</span>]);<br><br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = l; k &lt; r; k ++)<br>                    f2[l][r] = <span class="hljs-built_in">max</span>(f2[l][r], f2[l][k] + f2[k + <span class="hljs-number">1</span>][r] + s[r] - s[l - <span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br><br>    <span class="hljs-type">int</span> res = <span class="hljs-number">1e9</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>        res = <span class="hljs-built_in">min</span>(res, f1[i][i + n - <span class="hljs-number">1</span>]);<br>    cout &lt;&lt; res &lt;&lt; endl;<br><br>    res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>        res = <span class="hljs-built_in">max</span>(res, f2[i][i + n - <span class="hljs-number">1</span>]);<br><br>    cout &lt;&lt; res &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="树形dp"><a href="#树形dp" class="headerlink" title="树形dp"></a>树形dp</h2><p>在树上面进行dp父节点表示的状态集合用子节点来更新，父节点可能有多个状态（与状态机模型结合），通常采用dfs实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">AcWing 285. 没有上司的舞会</span><br><span class="hljs-comment">Ural 大学有 N 名职员，编号为 1∼N。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">他们的关系就像一棵以校长为根的树，父节点就是子节点的直接上司。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">每个职员有一个快乐指数，用整数 Hi 给出，其中 1≤i≤N。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">现在要召开一场周年庆宴会，不过，没有职员愿意和直接上司一起参会。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">在满足这个条件的前提下，主办方希望邀请一部分职员参会，使得所有参会职员的快乐指数总和最大，求这个最大值。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> PII = pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">6007</span>;<br>vector&lt;<span class="hljs-type">int</span>&gt; to[N];<br><span class="hljs-type">int</span> f[N][<span class="hljs-number">2</span>];<br><span class="hljs-type">int</span> a[N], father[N];<br><span class="hljs-type">int</span> n;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;   <br>    f[u][<span class="hljs-number">1</span>] = a[u];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> ver : to[u])&#123;<br>        <span class="hljs-built_in">dp</span>(ver);<br>        f[u][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(f[u][<span class="hljs-number">1</span>], f[ver][<span class="hljs-number">0</span>] + a[u]);<br>        f[u][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(&#123;f[u][<span class="hljs-number">0</span>], f[ver][<span class="hljs-number">0</span>], f[ver][<span class="hljs-number">1</span>]&#125;);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sovle</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;   <br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>        cin &gt;&gt; a[i];<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i ++)&#123;<br>        <span class="hljs-type">int</span> u, v;<br>        cin &gt;&gt; u &gt;&gt; v;<br>        father[u] = v; <br>        to[v].<span class="hljs-built_in">push_back</span>(u);<br>    &#125;<br><br>    <span class="hljs-type">int</span> root = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(father[root]) root ++;<br><br>    <span class="hljs-built_in">dp</span>(root);<br>    cout &lt;&lt; <span class="hljs-built_in">max</span>(f[root][<span class="hljs-number">1</span>], f[root][<span class="hljs-number">0</span>]) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>    cout &lt;&lt; <span class="hljs-built_in">setiosflags</span>(ios::fixed) &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">12</span>);<br><br>    <span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//cin &gt;&gt; T;</span><br>    <span class="hljs-keyword">while</span>(T --) <span class="hljs-built_in">sovle</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li><p>换根法</p><ul><li><p>一般每个点作为根答案不同</p></li><li><p>通常两次扫描，父节点利用子节点更新信息，子节点利用父节点更新信息</p></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">AcWing 287. 积蓄程度</span><br><span class="hljs-comment">有一个树形的水系，由 N−1 条河道和 N 个交叉点组成。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">我们可以把交叉点看作树中的节点，编号为 1∼N，河道则看作树中的无向边。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">每条河道都有一个容量，连接 x 与 y 的河道的容量记为 c(x,y)。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">河道中单位时间流过的水量不能超过河道的容量。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">有一个节点是整个水系的发源地，可以源源不断地流出水，我们称之为源点。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">除了源点之外，树中所有度数为 1 的节点都是入海口，可以吸收无限多的水，我们称之为汇点。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">也就是说，水系中的水从源点出发，沿着每条河道，最终流向各个汇点。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">在整个水系稳定时，每条河道中的水都以单位时间固定的水量流向固定的方向。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">除源点和汇点之外，其余各点不贮存水，也就是流入该点的河道水量之和等于从该点流出的河道水量之和。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">整个水系的流量就定义为源点单位时间发出的水量。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">在流量不超过河道容量的前提下，求哪个点作为源点时，整个水系的流量最大，输出这个最大值。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> LL = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">200010</span>, M = N &lt;&lt; <span class="hljs-number">1</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">int</span> h[N], e[M], w[M], ne[M], idx;<br><span class="hljs-type">int</span> up[N], down[N], deg[N];<br><span class="hljs-type">int</span> n;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v, <span class="hljs-type">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = v, w[idx] = c, ne[idx] = h[u], h[u] = idx ++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> fa)</span></span><br><span class="hljs-function"></span>&#123;   <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[u]; ~i; i = ne[i])&#123;<br>        <span class="hljs-type">int</span> ver = e[i];<br>        <span class="hljs-keyword">if</span>(ver == fa) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-built_in">dfs1</span>(ver, u);<br>        <span class="hljs-keyword">if</span>(deg[ver] == <span class="hljs-number">1</span>) down[u] += w[i];<br>        <span class="hljs-keyword">else</span> down[u] += <span class="hljs-built_in">min</span>(down[ver], w[i]);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> fa)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[u]; ~i; i = ne[i])&#123;<br>        <span class="hljs-type">int</span> ver = e[i];<br>        <span class="hljs-keyword">if</span>(ver == fa) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span>(deg[u] == <span class="hljs-number">1</span>) up[ver] = w[i];<br>        <span class="hljs-keyword">else</span> up[ver] = <span class="hljs-built_in">min</span>(w[i], down[u] - <span class="hljs-built_in">min</span>(down[ver], w[i]) + up[u]);<br>        <span class="hljs-built_in">dfs2</span>(ver, u);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sovle</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;   <br>    cin &gt;&gt; n;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-number">4</span> * (n + <span class="hljs-number">1</span>));<br>    <span class="hljs-built_in">memset</span>(down, <span class="hljs-number">0</span>, <span class="hljs-number">4</span> * (n + <span class="hljs-number">1</span>));<br>    <span class="hljs-built_in">memset</span>(up, <span class="hljs-number">0</span>, <span class="hljs-number">4</span> * (n + <span class="hljs-number">1</span>));<br>    <span class="hljs-built_in">memset</span>(deg, <span class="hljs-number">0</span>, <span class="hljs-number">4</span> * (n + <span class="hljs-number">1</span>));<br>    idx = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i ++)&#123;<br>        <span class="hljs-type">int</span> u, v, t;<br>        cin &gt;&gt; u &gt;&gt; v &gt;&gt; t;<br>        <span class="hljs-built_in">add</span>(u, v, t);<br>        <span class="hljs-built_in">add</span>(v, u, t);<br>        deg[u] ++, deg[v] ++;<br>    &#125;<br><br>    <span class="hljs-built_in">dfs1</span>(<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);<br>    <span class="hljs-built_in">dfs2</span>(<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)&#123;<br>        res = <span class="hljs-built_in">max</span>(res, down[i] + up[i]);<br>    &#125;<br><br>    cout &lt;&lt; res &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>    cout &lt;&lt; <span class="hljs-built_in">setiosflags</span>(ios::fixed) &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">12</span>);<br>    <span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<br>    cin &gt;&gt; T;<br>    <span class="hljs-keyword">while</span>(T --)&#123;<br>        <span class="hljs-built_in">sovle</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="环形后效性处理"><a href="#环形后效性处理" class="headerlink" title="环形后效性处理"></a>环形后效性处理</h2><p>所有的状态依赖关系构成环，需要进行特殊处理：</p><ul><li><p>分类讨论</p><p>可以假定某一环节的具体状态是什么，从而在这一状态下进行dp, 要把这一环节的所有状态都假定一遍</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">AcWing 288. 休息时间</span><br><span class="hljs-comment">在某个星球上，一天由 N 个小时构成，我们称 0 点到 1 点为第 1 个小时、1 点到 2 点为第 2 个小时，以此类推。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">在第 i 个小时睡觉能够恢复 Ui 点体力。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">在这个星球上住着一头牛，它每天要休息 B 个小时。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">它休息的这 B 个小时不一定连续，可以分成若干段，但是在每段的第一个小时，它需要从清醒逐渐入睡，不能恢复体力，从下一个小时开始才能睡着。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">为了身体健康，这头牛希望遵循生物钟，每天采用相同的睡觉计划。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">另外，因为时间是连续的，即每一天的第 N 个小时和下一天的第 1 个小时是相连的（N 点等于 0 点），这头牛只需要在每 N 个小时内休息够 B 个小时就可以了。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">请你帮忙给这头牛安排一个睡觉计划，使它每天恢复的体力最多。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> LL = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-type">int</span> mod = <span class="hljs-number">998&#x27;244&#x27;353</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">4000</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">int</span> f[<span class="hljs-number">2</span>][N][<span class="hljs-number">2</span>];<br><span class="hljs-type">int</span> a[N];<br><span class="hljs-type">int</span> n, m;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sovle</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123; <br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>        cin &gt;&gt; a[i];<br><br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//第n小时在睡觉</span><br>    <span class="hljs-built_in">memset</span>(f, <span class="hljs-number">-0x3f</span>, <span class="hljs-built_in">sizeof</span>(f));<br>    f[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>, f[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = a[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i ++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= m; j ++)&#123;<br>            f[i &amp; <span class="hljs-number">1</span>][j][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(f[i - <span class="hljs-number">1</span> &amp; <span class="hljs-number">1</span>][j][<span class="hljs-number">0</span>], f[i - <span class="hljs-number">1</span> &amp; <span class="hljs-number">1</span>][j][<span class="hljs-number">1</span>]);<br>            <span class="hljs-keyword">if</span>(j) f[i &amp; <span class="hljs-number">1</span>][j][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(f[i - <span class="hljs-number">1</span> &amp; <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], f[i - <span class="hljs-number">1</span> &amp; <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + a[i]);<br>        &#125;<br>    res = f[n &amp; <span class="hljs-number">1</span>][m][<span class="hljs-number">1</span>];<br><br>    <span class="hljs-comment">//第n小时不在睡觉</span><br>    <span class="hljs-built_in">memset</span>(f, <span class="hljs-number">-0x3f</span>, <span class="hljs-built_in">sizeof</span>(f));<br>    f[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>, f[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i ++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= m; j ++)&#123;<br>            f[i &amp; <span class="hljs-number">1</span>][j][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(f[i - <span class="hljs-number">1</span> &amp; <span class="hljs-number">1</span>][j][<span class="hljs-number">0</span>], f[i - <span class="hljs-number">1</span> &amp; <span class="hljs-number">1</span>][j][<span class="hljs-number">1</span>]);<br>            <span class="hljs-keyword">if</span>(j) f[i &amp; <span class="hljs-number">1</span>][j][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(f[i - <span class="hljs-number">1</span> &amp; <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], f[i - <span class="hljs-number">1</span> &amp; <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + a[i]);<br>        &#125;<br>    res = <span class="hljs-built_in">max</span>(res, f[n &amp; <span class="hljs-number">1</span>][m][<span class="hljs-number">0</span>]);<br><br>    cout &lt;&lt; res &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>    cout &lt;&lt; <span class="hljs-built_in">setiosflags</span>(ios::fixed) &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">12</span>);<br>    <span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//cin &gt;&gt; T;</span><br>    <span class="hljs-keyword">while</span>(T --)&#123;<br>        <span class="hljs-built_in">sovle</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>破环成链</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">AcWing 289. 环路运输</span><br><span class="hljs-comment">在一条环形公路旁均匀地分布着 N 座仓库，编号为 1∼N，编号为 i 的仓库与编号为 j 的仓库之间的距离定义为 dist(i,j)=min(|i−j|,N−|i−j|)，也就是逆时针或顺时针从 i 到 j 中较近的一种。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">每座仓库都存有货物，其中编号为 i 的仓库库存量为 Ai。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">在 i 和 j 两座仓库之间运送货物需要的代价为 Ai+Aj+dist(i,j)。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">求在哪两座仓库之间运送货物需要的代价最大</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> LL = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-type">int</span> mod = <span class="hljs-number">998&#x27;244&#x27;353</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2000007</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">int</span> a[N], q[N];<br><span class="hljs-type">int</span> n;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sovle</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123; <br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)&#123;<br>        cin &gt;&gt; a[i];<br>        a[i + n] = a[i];<br>    &#125;<br><br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int</span> k = n / <span class="hljs-number">2</span>;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n * <span class="hljs-number">2</span>; i ++)&#123;<br>        <span class="hljs-keyword">while</span>(hh &lt;= tt &amp;&amp; q[tt] - q[hh] + <span class="hljs-number">1</span> &gt; k) hh ++;<br>        <span class="hljs-keyword">if</span>(hh &lt;= tt) res = <span class="hljs-built_in">max</span>(res, i - q[hh] + a[i] + a[q[hh]]);<br>        <span class="hljs-keyword">while</span>(hh &lt;= tt &amp;&amp; -i + a[i] &gt;= -q[tt] + a[q[tt]]) tt --;<br>        q[++ tt] = i;<br>    &#125;<br><br>    cout &lt;&lt; res &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>    cout &lt;&lt; <span class="hljs-built_in">setiosflags</span>(ios::fixed) &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">12</span>);<br>    <span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//cin &gt;&gt; T;</span><br>    <span class="hljs-keyword">while</span>(T --)&#123;<br>        <span class="hljs-built_in">sovle</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>高斯消元处理环形后效性</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">给定一张 N×M 的棋盘，有一个机器人处于 (x,y) 位置。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">这个机器人可以进行很多轮行动，每次等概率地随机选择停在原地、向左移动一格、向右移动一格或向下移动一格。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">当然机器人不能移出棋盘。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">求机器人从起点走到最后一行的任意一个位置上，所需行动次数的数学期望值。</span><br><span class="hljs-comment">n &lt;= 1000</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> LL = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-type">int</span> mod = <span class="hljs-number">998&#x27;244&#x27;353</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1007</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">double</span> f[N][N];<br><span class="hljs-type">double</span> a[N][N];<br><span class="hljs-type">int</span> n, m, x, y;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">gauss</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i ++)&#123;<br>        <span class="hljs-type">double</span> t = a[i + <span class="hljs-number">1</span>][i] / a[i][i];<br>        a[i + <span class="hljs-number">1</span>][i] = <span class="hljs-number">0</span>;<br>        a[i + <span class="hljs-number">1</span>][i + <span class="hljs-number">1</span>] -= a[i][i + <span class="hljs-number">1</span>] * t;<br>        a[i + <span class="hljs-number">1</span>][m + <span class="hljs-number">1</span>] -= a[i][m + <span class="hljs-number">1</span>] * t;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = m; i &gt;= <span class="hljs-number">1</span>; i --)&#123;<br>        a[i - <span class="hljs-number">1</span>][m + <span class="hljs-number">1</span>] -= a[i - <span class="hljs-number">1</span>][i] / a[i][i] * a[i][m + <span class="hljs-number">1</span>];<br>        a[i - <span class="hljs-number">1</span>][i] = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i ++)&#123;<br>        a[i][m + <span class="hljs-number">1</span>] /= a[i][i];<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sovle</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123; <br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; x &gt;&gt; y;<br>    <span class="hljs-keyword">if</span>(m == <span class="hljs-number">1</span>) cout &lt;&lt; <span class="hljs-number">2.0</span> * (n - x) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= x; i --)&#123;<br>            a[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">2.0</span> / <span class="hljs-number">3</span>, a[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">-1.0</span> / <span class="hljs-number">3</span>;<br>            a[m][m - <span class="hljs-number">1</span>] = <span class="hljs-number">-1.0</span> / <span class="hljs-number">3</span>, a[m][m] = <span class="hljs-number">2.0</span> / <span class="hljs-number">3</span>;<br>            a[<span class="hljs-number">1</span>][m + <span class="hljs-number">1</span>] = f[i + <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] / <span class="hljs-number">3</span> + <span class="hljs-number">1</span>;<br>            a[m][m + <span class="hljs-number">1</span>] = f[i + <span class="hljs-number">1</span>][m] / <span class="hljs-number">3</span> + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">2</span>; j &lt; m; j ++)&#123;<br>                a[j][j - <span class="hljs-number">1</span>] = <span class="hljs-number">-1.0</span> / <span class="hljs-number">4</span>, a[j][j] = <span class="hljs-number">3.0</span> / <span class="hljs-number">4</span>, a[j][j + <span class="hljs-number">1</span>] = <span class="hljs-number">-1.0</span> / <span class="hljs-number">4</span>;<br>                a[j][m + <span class="hljs-number">1</span>] = f[i + <span class="hljs-number">1</span>][j] / <span class="hljs-number">4</span> + <span class="hljs-number">1</span>;<br>            &#125;<br><br>            <span class="hljs-built_in">gauss</span>();<br><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++)<br>                f[i][j] = a[j][m + <span class="hljs-number">1</span>];<br><br>        &#125;<br><br>        cout &lt;&lt; f[x][y] &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>    cout &lt;&lt; <span class="hljs-built_in">setiosflags</span>(ios::fixed) &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">4</span>);<br>    <span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//cin &gt;&gt; T;</span><br>    <span class="hljs-keyword">while</span>(T --)&#123;<br>        <span class="hljs-built_in">sovle</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="状态压缩dp"><a href="#状态压缩dp" class="headerlink" title="状态压缩dp"></a>状态压缩dp</h2><p>思想是用一个数，这个数的每个位置表示所有物品或者行列的状态</p><ul><li><p>棋盘式</p><p>一般是用一个数表示一行或者一列的状态</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">求把 N×M 的棋盘分割成若干个 1×2 的长方形，有多少种方案</span><br><span class="hljs-comment">1≤N,M≤11</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> LL = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-type">int</span> mod = <span class="hljs-number">998&#x27;244&#x27;353</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">12</span>, M = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">11</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br>LL f[N][M];<br><span class="hljs-type">bool</span> st[M];<br>vector&lt;<span class="hljs-type">int</span>&gt; from[M];<br><span class="hljs-type">int</span> n, m;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sovle</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123; <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1</span> &lt;&lt; n; i ++)&#123;<br>        <span class="hljs-type">bool</span> ok = <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j ++)<br>            <span class="hljs-keyword">if</span>(i &gt;&gt; j &amp; <span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">if</span>(cnt &amp; <span class="hljs-number">1</span>)&#123;<br>                    ok = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                cnt = <span class="hljs-number">0</span>;<br>            &#125;<span class="hljs-keyword">else</span> cnt ++;<br>        <span class="hljs-keyword">if</span>(cnt &amp; <span class="hljs-number">1</span>) ok = <span class="hljs-literal">false</span>;<br>        st[i] = ok;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1</span> &lt;&lt; n; i ++)&#123;<br>        from[i].<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">1</span> &lt;&lt; n; k ++)&#123;<br>            <span class="hljs-keyword">if</span>((i &amp; k) == <span class="hljs-number">0</span> &amp;&amp; st[i | k])&#123;<br>                from[i].<span class="hljs-built_in">push_back</span>(k);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">memset</span>(f, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(f));<br>    f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i ++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">1</span> &lt;&lt; n; j ++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> k : from[j])&#123;<br>                f[i][j] += f[i - <span class="hljs-number">1</span>][k];<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    cout &lt;&lt; f[m][<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>    cout &lt;&lt; <span class="hljs-built_in">setiosflags</span>(ios::fixed) &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">4</span>);<br>    <span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//cin &gt;&gt; T;</span><br>    <span class="hljs-keyword">while</span>(cin &gt;&gt; n &gt;&gt; m, n || m)&#123;<br>        <span class="hljs-built_in">sovle</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>集合式</p><p>用一个数表示每个”点“的状态</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">给定一张 n 个点的带权无向图，点从 0∼n−1 标号，求起点 0 到终点 n−1 的最短 Hamilton 路径。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Hamilton 路径的定义是从 0 到 n−1 不重不漏地经过每个点恰好一次。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> LL = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-type">int</span> mod = <span class="hljs-number">998&#x27;244&#x27;353</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">21</span>, M = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">20</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">int</span> d[N][N];<br><span class="hljs-type">int</span> f[M][N];<br><span class="hljs-type">int</span> n;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sovle</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;   <br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j ++)<br>            cin &gt;&gt; d[i][j];<br><br>    <span class="hljs-built_in">memset</span>(f, <span class="hljs-number">0x3f</span>, <span class="hljs-built_in">sizeof</span>(f));<br>    f[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1</span> &lt;&lt; n; i ++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j ++)&#123;<br>            <span class="hljs-keyword">if</span>(i &gt;&gt; j &amp; <span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; n; k ++)&#123;<br>                    <span class="hljs-keyword">if</span>(i &gt;&gt; k &amp; <span class="hljs-number">1</span>)&#123;<br>                        f[i][j] = <span class="hljs-built_in">min</span>(f[i][j], f[i - (<span class="hljs-number">1</span> &lt;&lt; j)][k] + d[k][j]);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>    cout &lt;&lt; f[(<span class="hljs-number">1</span> &lt;&lt; n) - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>    cout &lt;&lt; <span class="hljs-built_in">setiosflags</span>(ios::fixed) &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">4</span>);<br>    <span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//cin &gt;&gt; T;</span><br>    <span class="hljs-keyword">while</span>(T --)&#123;<br>        <span class="hljs-built_in">sovle</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="数位dp"><a href="#数位dp" class="headerlink" title="数位dp"></a>数位dp</h2><p>题目一般是给定一个区间求区间内满足某种性质的数的个数或其他东西</p><ul><li><p>递推</p><ul><li>.采用前缀和的思想，把要求的区间转化成两个区间的差</li><li>从高位到低位，采用一颗树的形式思考，左子树是这一位选择$0 \ldots a[i] - 1$的方案，右子树是这一位选择$a[i]$的方案 左子树所有的方案数通常可以通过预处理得到，预处理的过程大多数为dp，右子树一直能走到最后一位才能得到一种合法方案</li><li>这种分类的思想是基于：最终的方案每一位都要填一个数，从高位到地位考虑，分成两个子树（这样考虑的好处是，简便的使得考虑的方案都是小于区间上界的），这一位填的所有合法数的所有方案等价于所有合法的方案）。</li></ul></li><li><p>记忆化搜索</p></li></ul><p>​$f[i] [j]$记忆化的内容是从高到低位当前枚举到第$i$位，前面的状态为$j$(不包括第$i$位，$j$通常根据题目来定) 且不贴合上界(也就是这一位</p><p>​没有上界限制，只有题目限制)的方案数，递归辅助信息通常有是否有限制，是否有前导零等</p><p>​        这样表示状态的原因是，这一位没有贴合上界的方案比贴合上界的多，且前面状态用到不贴合上界的方案也多，把这一状态记忆化就能大大优化时间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">科协里最近很流行数字游戏。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">某人命名了一种不降数，这种数字必须满足从左到右各位数字呈非下降关系，如 123，446。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">现在大家决定玩一个游戏，指定一个整数闭区间 [a,b]，问这个区间内有多少个不降数。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> LL = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">998&#x27;244&#x27;353</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> N = <span class="hljs-number">40</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">int</span> f[N][<span class="hljs-number">10</span>];<br>vector&lt;<span class="hljs-type">int</span>&gt; nums;<br><span class="hljs-type">int</span> l, r;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> pre, <span class="hljs-type">int</span> lim)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(u == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">if</span>(!lim &amp;&amp; ~f[u][pre]) <span class="hljs-keyword">return</span> f[u][pre];<br><br>    <span class="hljs-type">int</span> mx = lim ? nums[u] : <span class="hljs-number">9</span>;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= mx; i ++)&#123;<br>        <span class="hljs-keyword">if</span>(i &lt; pre) <span class="hljs-keyword">continue</span>;<br>        res += <span class="hljs-built_in">dp</span>(u - <span class="hljs-number">1</span>, i, lim &amp;&amp; i == mx);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> lim ? res : f[u][pre] = res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(f, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(f));<br>    nums.<span class="hljs-built_in">clear</span>();<br>    <span class="hljs-keyword">while</span>(x) nums.<span class="hljs-built_in">push_back</span>(x % <span class="hljs-number">10</span>), x /= <span class="hljs-number">10</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">dp</span>(nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sovle</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;   <br>    cout &lt;&lt; <span class="hljs-built_in">calc</span>(r) - <span class="hljs-built_in">calc</span>(l - <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>    cout &lt;&lt; <span class="hljs-built_in">setiosflags</span>(ios::fixed) &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">4</span>);<br>    <span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//cin &gt;&gt; T;</span><br>    <span class="hljs-keyword">while</span>(cin &gt;&gt; l &gt;&gt; r)&#123;<br>        <span class="hljs-built_in">sovle</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>适当增加维护信息使得能够复用状态</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">给出两个数a,ba,b，求出[a,b][a,b]中各位数字之和能整除原数的数的个数。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> LL = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">998&#x27;244&#x27;353</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> N = <span class="hljs-number">20</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br>LL f[N][N * <span class="hljs-number">10</span>][N * <span class="hljs-number">10</span>];<br>vector&lt;<span class="hljs-type">int</span>&gt; nums;<br>LL l, r;<br>LL n;<br><br><span class="hljs-function">LL <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> sum, <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> lim)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(u == <span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-keyword">if</span>(sum == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(s == <span class="hljs-number">0</span> &amp;&amp; sum == n) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span>(!lim &amp;&amp; ~f[u][sum][s]) <span class="hljs-keyword">return</span> f[u][sum][s];<br><br>    <span class="hljs-type">int</span> mx = lim ? nums[u] : <span class="hljs-number">9</span>;<br>    LL res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= mx; i ++)&#123;<br>        res += <span class="hljs-built_in">dp</span>(u - <span class="hljs-number">1</span>, sum + i, (<span class="hljs-number">10ll</span> * s + i) % n,lim &amp;&amp; i == mx);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> lim ? res : f[u][sum][s] = res;<br>&#125;<br><br><span class="hljs-function">LL <span class="hljs-title">calc</span><span class="hljs-params">(LL x)</span></span><br><span class="hljs-function"></span>&#123;<br>    nums.<span class="hljs-built_in">clear</span>();<br>    <span class="hljs-keyword">while</span>(x) nums.<span class="hljs-built_in">push_back</span>(x % <span class="hljs-number">10</span>), x /= <span class="hljs-number">10</span>;<br><br>    LL res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(n = <span class="hljs-number">1</span>; n &lt;= <span class="hljs-number">9</span> * nums.<span class="hljs-built_in">size</span>(); n ++)&#123;<br>        <span class="hljs-built_in">memset</span>(f, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(f));<br>        res += <span class="hljs-built_in">dp</span>(nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sovle</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;   <br>    cin &gt;&gt; l &gt;&gt; r;<br>    cout &lt;&lt; <span class="hljs-built_in">calc</span>(r) - <span class="hljs-built_in">calc</span>(l - <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>    cout &lt;&lt; <span class="hljs-built_in">setiosflags</span>(ios::fixed) &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">4</span>);<br>    <span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//cin &gt;&gt; T;</span><br>    <span class="hljs-keyword">while</span>(T --)&#123;<br>        <span class="hljs-built_in">sovle</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="计数类dp"><a href="#计数类dp" class="headerlink" title="计数类dp"></a>计数类dp</h2><ul><li>计数类dp通常与组合数有关</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* AcWing 306.杰拉尔德和巨型象棋</span><br><span class="hljs-comment">给定一个 H×W 的棋盘，棋盘上只有 N 个格子是黑色的，其他格子都是白色的。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">在棋盘左上角有一个卒，每一步可以向右或向下移动一格，并且不能移动到黑色格子中。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">求这个卒从左上角移动到右下角，一共有多少种路线。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> LL = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">1000&#x27;000&#x27;007</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100007</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br>LL fact[N], infact[N];<br>LL f[<span class="hljs-number">2007</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qmi</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(k)&#123;<br>        <span class="hljs-keyword">if</span>(k &amp; <span class="hljs-number">1</span>) res = (LL)res * a % p;<br>        k &gt;&gt;= <span class="hljs-number">1</span>;<br>        a = (LL)a * a % p;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    fact[<span class="hljs-number">0</span>] = infact[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; N; i ++)&#123;<br>        fact[i] = (LL)fact[i - <span class="hljs-number">1</span>] * i % mod;<br>        infact[i] = (LL)infact[i - <span class="hljs-number">1</span>] * <span class="hljs-built_in">qmi</span>(i, mod - <span class="hljs-number">2</span>, mod) % mod; <br>    &#125;<br>&#125;<br><br><span class="hljs-function">LL <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> (LL)fact[a] * infact[b] % mod * infact[a - b] % mod;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sovle</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;   <br>    <span class="hljs-built_in">init</span>();<br>    <span class="hljs-type">int</span> n, m, k;<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;<br>    vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; a;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= k; i ++)&#123;<br>        <span class="hljs-type">int</span> x, y;<br>        cin &gt;&gt; x &gt;&gt; y;<br>        a.<span class="hljs-built_in">push_back</span>(&#123;x, y&#125;);<br>    &#125;<br>    a.<span class="hljs-built_in">push_back</span>(&#123;n, m&#125;);<br><br>    <span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>());<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; a.<span class="hljs-built_in">size</span>(); i ++)&#123;<br>        <span class="hljs-keyword">auto</span> [xi, yi] = a[i];<br>        f[i] = <span class="hljs-built_in">C</span>(xi - <span class="hljs-number">1</span> + yi - <span class="hljs-number">1</span>, xi - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j ++)&#123;<br>            <span class="hljs-keyword">auto</span> [xj, yj] = a[j];<br>            <span class="hljs-keyword">if</span>(xj &lt;= xi &amp;&amp; yj &lt;= yi)&#123;<br>                LL t = f[j] * <span class="hljs-built_in">C</span>(xi - xj + yi - yj, xi - xj) % mod;<br>                f[i] = (f[i] - t + mod) % mod;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    cout &lt;&lt; f[a.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>    cout &lt;&lt; <span class="hljs-built_in">setiosflags</span>(ios::fixed) &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">4</span>);<br>    <span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//cin &gt;&gt; T;</span><br>    <span class="hljs-keyword">while</span>(T --)&#123;<br>        <span class="hljs-built_in">sovle</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>状态机模型</li></ul><p>一个状态可能受到其他状态的影响，有可能几个状态组合才能完成一次完整操作，因此可以把每个状态分离开来，每个点都有多种状态，就每个点的多种状态求解</p><ul><li><p>单调队列优化dp</p><p>状态转移需要是一段连续数的最大值或最小值，用单调队列来优化</p></li><li><p>斜率优化dp</p><p>通常状态转移都是需要前面一堆状态的值来转移，(目的要找斜率第一条大于当前斜率的点)</p><p>优化的方式就是把前面需要的每个状态看成一个点，当前状态就是一条斜率固定的直线</p><p>这样可以分成两种1.每个状态的直线斜率依次递增，每次加进来的点横坐标递增，这样只需对头队尾分别维护即可， 对头就是最值</p><p>​  2.每个状态的直线斜率不定，每次加进来的点横坐标递增，每次队尾依然可以维护，但对头不行，最值需要二分来找。</p></li></ul><h1 id="六、其他知识点"><a href="#六、其他知识点" class="headerlink" title="六、其他知识点"></a>六、其他知识点</h1><ul><li><p>排序不等式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">对于非严格递增序列a1 ~ an, b1 ~ bn,<br>ai * bi相加的最大值是a1 * b1 + ... + an * bn<br>    最小值是a1 * bn + ... + an * b1<br>理解 同序相乘一定大于逆序相乘，最大就都是同序， 最小就都是逆序<br></code></pre></td></tr></table></figure></li><li><p>$O(1)$计算一个点到若干点的最大曼哈顿距离</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">Codeforces Round #798 (Div. 2) 1689_D</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> LL = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> PII = pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;;<br><span class="hljs-keyword">using</span> PLL = pair&lt;LL , LL&gt;;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>, M = N &lt;&lt; <span class="hljs-number">1</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">998244353</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">char</span> g[N][N];<br><span class="hljs-type">int</span> n, m;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;  <br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-type">int</span> mx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-built_in">memset</span>(mx, <span class="hljs-number">-0x3f</span>, <span class="hljs-built_in">sizeof</span>(mx));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++)&#123;<br>            cin &gt;&gt; g[i][j];<br><br>            <span class="hljs-keyword">if</span>(g[i][j] == <span class="hljs-string">&#x27;B&#x27;</span>)&#123;<br>                mx[<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(mx[<span class="hljs-number">0</span>], i + j);<br>                mx[<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(mx[<span class="hljs-number">1</span>], -i - j);<br>                mx[<span class="hljs-number">2</span>] = <span class="hljs-built_in">max</span>(mx[<span class="hljs-number">2</span>], - i + j);<br>                mx[<span class="hljs-number">3</span>] = <span class="hljs-built_in">max</span>(mx[<span class="hljs-number">3</span>], i - j);<br>            &#125;<br>        &#125;<br>    <br>    <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>, ans = INF;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++)&#123;<br>            <span class="hljs-type">int</span> t = <span class="hljs-built_in">max</span>(&#123;<br>                mx[<span class="hljs-number">0</span>] - i - j,<span class="hljs-comment">//所有在我右下角距离我最远的</span><br>                mx[<span class="hljs-number">1</span>] + i + j ,<span class="hljs-comment">//所有在我左上角距离我最远的</span><br>                mx[<span class="hljs-number">2</span>] + i - j,<span class="hljs-comment">//所有在我右上角距离我最远的</span><br>                mx[<span class="hljs-number">3</span>] + j - i,<span class="hljs-comment">//所有在我左下角距离我最远的</span><br>            &#125;);<br><br>            <span class="hljs-keyword">if</span>(t &lt; ans)&#123;<br>                x = i, y = j;<br>                ans = t;<br>            &#125;<br>        &#125;<br><br>    cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; y &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>   <br>    <span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<br>    cin &gt;&gt; T;<br>    <span class="hljs-keyword">while</span>(T --) <span class="hljs-built_in">solve</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>快速枚举集合的非全子集</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//i为二进制数表示元素存在与否，j就为i的所有非全子集</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">1</span> &lt;&lt; n; i ++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = (i - <span class="hljs-number">1</span>) &amp; i; j; j = (j - <span class="hljs-number">1</span>) &amp; i)&#123;<br><br>        &#125;<br>    &#125;<br><br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>测试文章</title>
    <link href="/2023/01/08/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/"/>
    <url>/2023/01/08/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<img src="/2023/01/08/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/1.jpg" class="" title="图片引用方法一"> ]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/01/08/hello-world/"/>
    <url>/2023/01/08/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
